(function() {const t = document.createElement('link').relList; if (t && t.supports && t.supports('modulepreload')) return; for (const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n); new MutationObserver(n=>{for (const r of n) if (r.type === 'childList') for (const o of r.addedNodes)o.tagName === 'LINK' && o.rel === 'modulepreload' && s(o)}).observe(document, { childList:!0, subtree:!0 }); function e(n) {const r = {}; return n.integrity && (r.integrity = n.integrity), n.referrerPolicy && (r.referrerPolicy = n.referrerPolicy), n.crossOrigin === 'use-credentials' ? r.credentials = 'include' : n.crossOrigin === 'anonymous' ? r.credentials = 'omit' : r.credentials = 'same-origin', r} function s(n) {if (n.ep) return; n.ep = !0; const r = e(n); fetch(n.href, r)}})(); var ss, oi; function Nr() {if (oi) return ss; oi = 1; function i(g) {this._maxSize = g, this.clear()}i.prototype.clear = function() {this._size = 0, this._values = Object.create(null)}, i.prototype.get = function(g) {return this._values[g]}, i.prototype.set = function(g, E) {return this._size >= this._maxSize && this.clear(), g in this._values || this._size++, this._values[g] = E}; var t = /[^.^\]^[]+|(?=\[\]|\.\.)/g, e = /^\d+$/, s = /^\d/, n = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, r = /^\s*(['"]?)(.*?)(\1)\s*$/, o = 512, a = new i(o), l = new i(o), c = new i(o); ss = { Cache:i, split:h, normalizePath:u, setter:function(g) {var E = u(g); return l.get(g) || l.set(g, function(v, y) {for (var T = 0, A = E.length, N = v; T < A - 1;) {var x = E[T]; if (x === '__proto__' || x === 'constructor' || x === 'prototype') return v; N = N[E[T++]]}N[E[T]] = y})}, getter:function(g, E) {var S = u(g); return c.get(g) || c.set(g, function(y) {for (var T = 0, A = S.length; T < A;) if (y != null || !E)y = y[S[T++]]; else return; return y})}, join:function(g) {return g.reduce(function(E, S) {return E + (f(S) || e.test(S) ? '[' + S + ']' : (E ? '.' : '') + S)}, '')}, forEach:function(g, E, S) {p(Array.isArray(g) ? g : h(g), E, S)} }; function u(g) {return a.get(g) || a.set(g, h(g).map(function(E) {return E.replace(r, '$2')}))} function h(g) {return g.match(t) || ['']} function p(g, E, S) {var v = g.length, y, T, A, N; for (T = 0; T < v; T++)y = g[T], y && (b(y) && (y = '"' + y + '"'), N = f(y), A = !N && /^\d+$/.test(y), E.call(S, y, N, A, T, g))} function f(g) {return typeof g == 'string' && g && ['\'', '"'].indexOf(g.charAt(0)) !== -1} function m(g) {return g.match(s) && !g.match(e)} function _(g) {return n.test(g)} function b(g) {return !f(g) && (m(g) || _(g))} return ss} var ln = Nr(), Te = { exports:{} }, ai; function Lr() {if (ai) return Te.exports; ai = 1, Te.exports = function(n) {return i(t(n), n)}, Te.exports.array = i; function i(n, r) {var o = n.length, a = new Array(o), l = {}, c = o, u = e(r), h = s(n); for (r.forEach(function(f) {if (!h.has(f[0]) || !h.has(f[1])) throw new Error('Unknown node. There is an unknown node in the supplied edges.')}); c--;)l[c] || p(n[c], c, new Set); return a; function p(f, m, _) {if (_.has(f)) {var b; try {b = ', node was:' + JSON.stringify(f)} catch {b = ''} throw new Error('Cyclic dependency' + b)} if (!h.has(f)) throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(f)); if (!l[m]) {l[m] = !0; var g = u.get(f) || new Set; if (g = Array.from(g), m = g.length) {_.add(f); do {var E = g[--m]; p(E, h.get(E), _)} while (m); _.delete(f)}a[--o] = f}}} function t(n) {for (var r = new Set, o = 0, a = n.length; o < a; o++) {var l = n[o]; r.add(l[0]), r.add(l[1])} return Array.from(r)} function e(n) {for (var r = new Map, o = 0, a = n.length; o < a; o++) {var l = n[o]; r.has(l[0]) || r.set(l[0], new Set), r.has(l[1]) || r.set(l[1], new Set), r.get(l[0]).add(l[1])} return r} function s(n) {for (var r = new Map, o = 0, a = n.length; o < a; o++)r.set(n[o], o); return r} return Te.exports}Lr(); const Dr = Object.prototype.toString, Ir = Error.prototype.toString, Pr = RegExp.prototype.toString, Rr = typeof Symbol < 'u' ? Symbol.prototype.toString : ()=>'', kr = /^Symbol\((.*)\)(.*)$/; function Fr(i) {return i != +i ? 'NaN' : i === 0 && 1 / i < 0 ? '-0' : '' + i} function li(i, t = !1) {if (i == null || i === !0 || i === !1) return '' + i; const e = typeof i; if (e === 'number') return Fr(i); if (e === 'string') return t ? `"${i}"` : i; if (e === 'function') return '[Function ' + (i.name || 'anonymous') + ']'; if (e === 'symbol') return Rr.call(i).replace(kr, 'Symbol($1)'); const s = Dr.call(i).slice(8, -1); return s === 'Date' ? isNaN(i.getTime()) ? '' + i : i.toISOString(i) : s === 'Error' || i instanceof Error ? '[' + Ir.call(i) + ']' : s === 'RegExp' ? Pr.call(i) : null} function _t(i, t) {let e = li(i, t); return e !== null ? e : JSON.stringify(i, function(s, n) {let r = li(this[s], t); return r !== null ? r : n}, 2)} function cn(i) {return i == null ? [] : [].concat(i)} let un, hn, fn, Mr = /\$\{\s*(\w+)\s*\}/g; un = Symbol.toStringTag; class ci {constructor(t, e, s, n) {this.name = void 0, this.message = void 0, this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = void 0, this.inner = void 0, this[un] = 'Error', this.name = 'ValidationError', this.value = e, this.path = s, this.type = n, this.errors = [], this.inner = [], cn(t).forEach(r=>{if (M.isError(r)) {this.errors.push(...r.errors); const o = r.inner.length ? r.inner : [r]; this.inner.push(...o)} else this.errors.push(r)}), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]}}hn = Symbol.hasInstance; fn = Symbol.toStringTag; class M extends Error {static formatError(t, e) {const s = e.label || e.path || 'this'; return e = Object.assign({}, e, { path:s, originalPath:e.path }), typeof t == 'string' ? t.replace(Mr, (n, r)=>_t(e[r])) : typeof t == 'function' ? t(e) : t} static isError(t) {return t && t.name === 'ValidationError'}constructor(t, e, s, n, r) {const o = new ci(t, e, s, n); if (r) return o; super(), this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = [], this.inner = [], this[fn] = 'Error', this.name = o.name, this.message = o.message, this.type = o.type, this.value = o.value, this.path = o.path, this.errors = o.errors, this.inner = o.inner, Error.captureStackTrace && Error.captureStackTrace(this, M)} static [hn](t) {return ci[Symbol.hasInstance](t) || super[Symbol.hasInstance](t)}} let it = { default:'${path} is invalid', required:'${path} is a required field', defined:'${path} must be defined', notNull:'${path} cannot be null', oneOf:'${path} must be one of the following values: ${values}', notOneOf:'${path} must not be one of the following values: ${values}', notType:({ path:i, type:t, value:e, originalValue:s })=>{const n = s != null && s !== e ? ` (cast from the value \`${_t(s, !0)}\`).` : '.'; return t !== 'mixed' ? `${i} must be a \`${t}\` type, but the final value was: \`${_t(e, !0)}\`` + n : `${i} must match the configured type. The validated value was: \`${_t(e, !0)}\`` + n} }, H = { length:'${path} must be exactly ${length} characters', min:'${path} must be at least ${min} characters', max:'${path} must be at most ${max} characters', matches:'${path} must match the following: "${regex}"', email:'${path} must be a valid email', url:'${path} must be a valid URL', uuid:'${path} must be a valid UUID', datetime:'${path} must be a valid ISO date-time', datetime_precision:'${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits', datetime_offset:'${path} must be a valid ISO date-time with UTC "Z" timezone', trim:'${path} must be a trimmed string', lowercase:'${path} must be a lowercase string', uppercase:'${path} must be a upper case string' }, Vr = { min:'${path} must be greater than or equal to ${min}', max:'${path} must be less than or equal to ${max}', lessThan:'${path} must be less than ${less}', moreThan:'${path} must be greater than ${more}', positive:'${path} must be a positive number', negative:'${path} must be a negative number', integer:'${path} must be an integer' }, bs = { min:'${path} field must be later than ${min}', max:'${path} field must be at earlier than ${max}' }, jr = { isValue:'${path} field must be ${value}' }, Hr = { noUnknown:'${path} field has unspecified keys: ${unknown}', exact:'${path} object contains unknown properties: ${properties}' }, Kr = { min:'${path} field must have at least ${min} items', max:'${path} field must have less than or equal to ${max} items', length:'${path} must have ${length} items' }, Br = { notType:i=>{const { path:t, value:e, spec:s } = i, n = s.types.length; if (Array.isArray(e)) {if (e.length < n) return `${t} tuple value has too few items, expected a length of ${n} but got ${e.length} for value: \`${_t(e, !0)}\``; if (e.length > n) return `${t} tuple value has too many items, expected a length of ${n} but got ${e.length} for value: \`${_t(e, !0)}\``} return M.formatError(it.notType, i)} }; var Wr = Object.assign(Object.create(null), { mixed:it, string:H, number:Vr, date:bs, object:Hr, array:Kr, boolean:jr, tuple:Br }); const dn = i=>i && i.__isYupSchema__; class Re {static fromOptions(t, e) {if (!e.then && !e.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions'); let { is:s, then:n, otherwise:r } = e, o = typeof s == 'function' ? s : (...a)=>a.every(l=>l === s); return new Re(t, (a, l)=>{var c; let u = o(...a) ? n : r; return (c = u?.(l)) != null ? c : l})}constructor(t, e) {this.fn = void 0, this.refs = t, this.refs = t, this.fn = e}resolve(t, e) {let s = this.refs.map(r=>r.getValue(e?.value, e?.parent, e?.context)), n = this.fn(s, t, e); if (n === void 0 || n === t) return t; if (!dn(n)) throw new TypeError('conditions must return a schema object'); return n.resolve(e)}} const we = { context:'$', value:'.' }; class pe {constructor(t, e = {}) {if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof t != 'string') throw new TypeError('ref must be a string, got: ' + t); if (this.key = t.trim(), t === '') throw new TypeError('ref must be a non-empty string'); this.isContext = this.key[0] === we.context, this.isValue = this.key[0] === we.value, this.isSibling = !this.isContext && !this.isValue; let s = this.isContext ? we.context : this.isValue ? we.value : ''; this.path = this.key.slice(s.length), this.getter = this.path && ln.getter(this.path, !0), this.map = e.map}getValue(t, e, s) {let n = this.isContext ? s : this.isValue ? t : e; return this.getter && (n = this.getter(n || {})), this.map && (n = this.map(n)), n}cast(t, e) {return this.getValue(t, e?.parent, e?.context)}resolve() {return this}describe() {return { type:'ref', key:this.key }}toString() {return `Ref(${this.key})`} static isRef(t) {return t && t.__isYupRef}}pe.prototype.__isYupRef = !0; const Ct = i=>i == null; function Ft(i) {function t({ value:e, path:s = '', options:n, originalValue:r, schema:o }, a, l) {const { name:c, test:u, params:h, message:p, skipAbsent:f } = i; let { parent:m, context:_, abortEarly:b = o.spec.abortEarly, disableStackTrace:g = o.spec.disableStackTrace } = n; const E = { value:e, parent:m, context:_ }; function S(C = {}) {const R = pn(Object.assign({ value:e, originalValue:r, label:o.spec.label, path:C.path || s, spec:o.spec, disableStackTrace:C.disableStackTrace || g }, h, C.params), E), L = new M(M.formatError(C.message || p, R), e, R.path, C.type || c, R.disableStackTrace); return L.params = R, L} const v = b ? a : l; let y = { path:s, parent:m, type:c, from:n.from, createError:S, resolve(C) {return gn(C, E)}, options:n, originalValue:r, schema:o }; const T = C=>{M.isError(C) ? v(C) : C ? l(null) : v(S())}, A = C=>{M.isError(C) ? v(C) : a(C)}; if (f && Ct(e)) return T(!0); let x; try {var $; if (x = u.call(y, e, y), typeof(($ = x) == null ? void 0 : $.then) == 'function') {if (n.sync) throw new Error(`Validation test of type: "${y.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`); return Promise.resolve(x).then(T, A)}} catch (C) {A(C); return}T(x)} return t.OPTIONS = i, t} function pn(i, t) {if (!i) return i; for (const e of Object.keys(i))i[e] = gn(i[e], t); return i} function gn(i, t) {return pe.isRef(i) ? i.getValue(t.value, t.parent, t.context) : i} function Ur(i, t, e, s = e) {let n, r, o; return t ? (ln.forEach(t, (a, l, c)=>{let u = l ? a.slice(1, a.length - 1) : a; i = i.resolve({ context:s, parent:n, value:e }); let h = i.type === 'tuple', p = c ? parseInt(u, 10) : 0; if (i.innerType || h) {if (h && !c) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${o}" must contain an index to the tuple element, e.g. "${o}[0]"`); if (e && p >= e.length) throw new Error(`Yup.reach cannot resolve an array item at index: ${a}, in the path: ${t}. because there is no value at that index. `); n = e, e = e && e[p], i = h ? i.spec.types[p] : i.innerType} if (!c) {if (!i.fields || !i.fields[u]) throw new Error(`The schema does not contain the path: ${t}. (failed at: ${o} which is a type: "${i.type}")`); n = e, e = e && e[u], i = i.fields[u]}r = u, o = l ? '[' + a + ']' : '.' + a}), { schema:i, parent:n, parentPath:r }) : { parent:n, parentPath:t, schema:i }} class ke extends Set {describe() {const t = []; for (const e of this.values())t.push(pe.isRef(e) ? e.describe() : e); return t}resolveAll(t) {let e = []; for (const s of this.values())e.push(t(s)); return e}clone() {return new ke(this.values())}merge(t, e) {const s = this.clone(); return t.forEach(n=>s.add(n)), e.forEach(n=>s.delete(n)), s}} function Wt(i, t = new Map) {if (dn(i) || !i || typeof i != 'object') return i; if (t.has(i)) return t.get(i); let e; if (i instanceof Date)e = new Date(i.getTime()), t.set(i, e); else if (i instanceof RegExp)e = new RegExp(i), t.set(i, e); else if (Array.isArray(i)) {e = new Array(i.length), t.set(i, e); for (let s = 0; s < i.length; s++)e[s] = Wt(i[s], t)} else if (i instanceof Map) {e = new Map, t.set(i, e); for (const [s, n] of i.entries())e.set(s, Wt(n, t))} else if (i instanceof Set) {e = new Set, t.set(i, e); for (const s of i)e.add(Wt(s, t))} else if (i instanceof Object) {e = {}, t.set(i, e); for (const [s, n] of Object.entries(i))e[s] = Wt(n, t)} else throw Error(`Unable to clone ${i}`); return e} function zr(i) {if (!(i != null && i.length)) return; const t = []; let e = '', s = !1, n = !1; for (let r = 0; r < i.length; r++) {const o = i[r]; if (o === '[' && !n) {e && (t.push(...e.split('.').filter(Boolean)), e = ''), s = !0; continue} if (o === ']' && !n) {e && (/^\d+$/.test(e) ? t.push(e) : t.push(e.replace(/^"|"$/g, '')), e = ''), s = !1; continue} if (o === '"') {n = !n; continue} if (o === '.' && !s && !n) {e && (t.push(e), e = ''); continue}e += o} return e && t.push(...e.split('.').filter(Boolean)), t} function Yr(i, t) {const e = t ? `${t}.${i.path}` : i.path; return i.errors.map(s=>({ message:s, path:zr(e) }))} function mn(i, t) {var e; if (!((e = i.inner) != null && e.length) && i.errors.length) return Yr(i, t); const s = t ? `${t}.${i.path}` : i.path; return i.inner.flatMap(n=>mn(n, s))} class Et {constructor(t) {this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new ke, this._blacklist = new ke, this.exclusiveTests = Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(()=>{this.typeError(it.notType)}), this.type = t.type, this._typeCheck = t.check, this.spec = Object.assign({ strip:!1, strict:!1, abortEarly:!0, recursive:!0, disableStackTrace:!1, nullable:!1, optional:!0, coerce:!0 }, t?.spec), this.withMutation(e=>{e.nonNullable()})} get _type() {return this.type}clone(t) {if (this._mutate) return t && Object.assign(this.spec, t), this; const e = Object.create(Object.getPrototypeOf(this)); return e.type = this.type, e._typeCheck = this._typeCheck, e._whitelist = this._whitelist.clone(), e._blacklist = this._blacklist.clone(), e.internalTests = Object.assign({}, this.internalTests), e.exclusiveTests = Object.assign({}, this.exclusiveTests), e.deps = [...this.deps], e.conditions = [...this.conditions], e.tests = [...this.tests], e.transforms = [...this.transforms], e.spec = Wt(Object.assign({}, this.spec, t)), e}label(t) {let e = this.clone(); return e.spec.label = t, e}meta(...t) {if (t.length === 0) return this.spec.meta; let e = this.clone(); return e.spec.meta = Object.assign(e.spec.meta || {}, t[0]), e}withMutation(t) {let e = this._mutate; this._mutate = !0; let s = t(this); return this._mutate = e, s}concat(t) {if (!t || t === this) return this; if (t.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${t.type}`); let e = this, s = t.clone(); const n = Object.assign({}, e.spec, s.spec); return s.spec = n, s.internalTests = Object.assign({}, e.internalTests, s.internalTests), s._whitelist = e._whitelist.merge(t._whitelist, t._blacklist), s._blacklist = e._blacklist.merge(t._blacklist, t._whitelist), s.tests = e.tests, s.exclusiveTests = e.exclusiveTests, s.withMutation(r=>{t.tests.forEach(o=>{r.test(o.OPTIONS)})}), s.transforms = [...e.transforms, ...s.transforms], s}isType(t) {return t == null ? !!(this.spec.nullable && t === null || this.spec.optional && t === void 0) : this._typeCheck(t)}resolve(t) {let e = this; if (e.conditions.length) {let s = e.conditions; e = e.clone(), e.conditions = [], e = s.reduce((n, r)=>r.resolve(n, t), e), e = e.resolve(t)} return e}resolveOptions(t) {var e, s, n, r; return Object.assign({}, t, { from:t.from || [], strict:(e = t.strict) != null ? e : this.spec.strict, abortEarly:(s = t.abortEarly) != null ? s : this.spec.abortEarly, recursive:(n = t.recursive) != null ? n : this.spec.recursive, disableStackTrace:(r = t.disableStackTrace) != null ? r : this.spec.disableStackTrace })}cast(t, e = {}) {let s = this.resolve(Object.assign({ value:t }, e)), n = e.assert === 'ignore-optionality', r = s._cast(t, e); if (e.assert !== !1 && !s.isType(r)) {if (n && Ct(r)) return r; let o = _t(t), a = _t(r); throw new TypeError(`The value of ${e.path || 'field'} could not be cast to a value that satisfies the schema type: "${s.type}". 

attempted value: ${o} 
` + (a !== o ? `result of cast: ${a}` : ''))} return r}_cast(t, e) {let s = t === void 0 ? t : this.transforms.reduce((n, r)=>r.call(this, n, t, this), t); return s === void 0 && (s = this.getDefault(e)), s}_validate(t, e = {}, s, n) {let { path:r, originalValue:o = t, strict:a = this.spec.strict } = e, l = t; a || (l = this._cast(l, Object.assign({ assert:!1 }, e))); let c = []; for (let u of Object.values(this.internalTests))u && c.push(u); this.runTests({ path:r, value:l, originalValue:o, options:e, tests:c }, s, u=>{if (u.length) return n(u, l); this.runTests({ path:r, value:l, originalValue:o, options:e, tests:this.tests }, s, n)})}runTests(t, e, s) {let n = !1, { tests:r, value:o, originalValue:a, path:l, options:c } = t, u = _=>{n || (n = !0, e(_, o))}, h = _=>{n || (n = !0, s(_, o))}, p = r.length, f = []; if (!p) return h([]); let m = { value:o, originalValue:a, path:l, options:c, schema:this }; for (let _ = 0; _ < r.length; _++) {const b = r[_]; b(m, u, function(E) {E && (Array.isArray(E) ? f.push(...E) : f.push(E)), --p <= 0 && h(f)})}}asNestedTest({ key:t, index:e, parent:s, parentPath:n, originalParent:r, options:o }) {const a = t ?? e; if (a == null) throw TypeError('Must include `key` or `index` for nested validations'); const l = typeof a == 'number'; let c = s[a]; const u = Object.assign({}, o, { strict:!0, parent:s, value:c, originalValue:r[a], key:void 0, [l ? 'index' : 'key']:a, path:l || a.includes('.') ? `${n || ''}[${l ? a : `"${a}"`}]` : (n ? `${n}.` : '') + t }); return (h, p, f)=>this.resolve(u)._validate(c, u, p, f)}validate(t, e) {var s; let n = this.resolve(Object.assign({}, e, { value:t })), r = (s = e?.disableStackTrace) != null ? s : n.spec.disableStackTrace; return new Promise((o, a)=>n._validate(t, e, (l, c)=>{M.isError(l) && (l.value = c), a(l)}, (l, c)=>{l.length ? a(new M(l, c, void 0, void 0, r)) : o(c)}))}validateSync(t, e) {var s; let n = this.resolve(Object.assign({}, e, { value:t })), r, o = (s = e?.disableStackTrace) != null ? s : n.spec.disableStackTrace; return n._validate(t, Object.assign({}, e, { sync:!0 }), (a, l)=>{throw M.isError(a) && (a.value = l), a}, (a, l)=>{if (a.length) throw new M(a, t, void 0, void 0, o); r = l}), r}isValid(t, e) {return this.validate(t, e).then(()=>!0, s=>{if (M.isError(s)) return !1; throw s})}isValidSync(t, e) {try {return this.validateSync(t, e), !0} catch (s) {if (M.isError(s)) return !1; throw s}}_getDefault(t) {let e = this.spec.default; return e == null ? e : typeof e == 'function' ? e.call(this, t) : Wt(e)}getDefault(t) {return this.resolve(t || {})._getDefault(t)}default(t) {return arguments.length === 0 ? this._getDefault() : this.clone({ default:t })}strict(t = !0) {return this.clone({ strict:t })}nullability(t, e) {const s = this.clone({ nullable:t }); return s.internalTests.nullable = Ft({ message:e, name:'nullable', test(n) {return n === null ? this.schema.spec.nullable : !0} }), s}optionality(t, e) {const s = this.clone({ optional:t }); return s.internalTests.optionality = Ft({ message:e, name:'optionality', test(n) {return n === void 0 ? this.schema.spec.optional : !0} }), s}optional() {return this.optionality(!0)}defined(t = it.defined) {return this.optionality(!1, t)}nullable() {return this.nullability(!0)}nonNullable(t = it.notNull) {return this.nullability(!1, t)}required(t = it.required) {return this.clone().withMutation(e=>e.nonNullable(t).defined(t))}notRequired() {return this.clone().withMutation(t=>t.nullable().optional())}transform(t) {let e = this.clone(); return e.transforms.push(t), e}test(...t) {let e; if (t.length === 1 ? typeof t[0] == 'function' ? e = { test:t[0] } : e = t[0] : t.length === 2 ? e = { name:t[0], test:t[1] } : e = { name:t[0], message:t[1], test:t[2] }, e.message === void 0 && (e.message = it.default), typeof e.test != 'function') throw new TypeError('`test` is a required parameters'); let s = this.clone(), n = Ft(e), r = e.exclusive || e.name && s.exclusiveTests[e.name] === !0; if (e.exclusive && !e.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test'); return e.name && (s.exclusiveTests[e.name] = !!e.exclusive), s.tests = s.tests.filter(o=>!(o.OPTIONS.name === e.name && (r || o.OPTIONS.test === n.OPTIONS.test))), s.tests.push(n), s}when(t, e) {!Array.isArray(t) && typeof t != 'string' && (e = t, t = '.'); let s = this.clone(), n = cn(t).map(r=>new pe(r)); return n.forEach(r=>{r.isSibling && s.deps.push(r.key)}), s.conditions.push(typeof e == 'function' ? new Re(n, e) : Re.fromOptions(n, e)), s}typeError(t) {let e = this.clone(); return e.internalTests.typeError = Ft({ message:t, name:'typeError', skipAbsent:!0, test(s) {return this.schema._typeCheck(s) ? !0 : this.createError({ params:{ type:this.schema.type } })} }), e}oneOf(t, e = it.oneOf) {let s = this.clone(); return t.forEach(n=>{s._whitelist.add(n), s._blacklist.delete(n)}), s.internalTests.whiteList = Ft({ message:e, name:'oneOf', skipAbsent:!0, test(n) {let r = this.schema._whitelist, o = r.resolveAll(this.resolve); return o.includes(n) ? !0 : this.createError({ params:{ values:Array.from(r).join(', '), resolved:o } })} }), s}notOneOf(t, e = it.notOneOf) {let s = this.clone(); return t.forEach(n=>{s._blacklist.add(n), s._whitelist.delete(n)}), s.internalTests.blacklist = Ft({ message:e, name:'notOneOf', test(n) {let r = this.schema._blacklist, o = r.resolveAll(this.resolve); return o.includes(n) ? this.createError({ params:{ values:Array.from(r).join(', '), resolved:o } }) : !0} }), s}strip(t = !0) {let e = this.clone(); return e.spec.strip = t, e}describe(t) {const e = (t ? this.resolve(t) : this).clone(), { label:s, meta:n, optional:r, nullable:o } = e.spec; return { meta:n, label:s, optional:r, nullable:o, default:e.getDefault(t), type:e.type, oneOf:e._whitelist.describe(), notOneOf:e._blacklist.describe(), tests:e.tests.filter((l, c, u)=>u.findIndex(h=>h.OPTIONS.name === l.OPTIONS.name) === c).map(l=>{const c = l.OPTIONS.params && t ? pn(Object.assign({}, l.OPTIONS.params), t) : l.OPTIONS.params; return { name:l.OPTIONS.name, params:c }}) }} get '~standard'() {const t = this; return { version:1, vendor:'yup', async validate(s) {try {return { value:await t.validate(s, { abortEarly:!1 }) }} catch (n) {if (n instanceof M) return { issues:mn(n) }; throw n}} }}}Et.prototype.__isYupSchema__ = !0; for (const i of ['validate', 'validateSync'])Et.prototype[`${i}At`] = function(t, e, s = {}) {const { parent:n, parentPath:r, schema:o } = Ur(this, t, e, s.context); return o[i](n && n[r], Object.assign({}, s, { parent:n, path:t }))}; for (const i of ['equals', 'is'])Et.prototype[i] = Et.prototype.oneOf; for (const i of ['not', 'nope'])Et.prototype[i] = Et.prototype.notOneOf; const qr = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/; function Gr(i) {const t = ys(i); if (!t) return Date.parse ? Date.parse(i) : Number.NaN; if (t.z === void 0 && t.plusMinus === void 0) return new Date(t.year, t.month, t.day, t.hour, t.minute, t.second, t.millisecond).valueOf(); let e = 0; return t.z !== 'Z' && t.plusMinus !== void 0 && (e = t.hourOffset * 60 + t.minuteOffset, t.plusMinus === '+' && (e = 0 - e)), Date.UTC(t.year, t.month, t.day, t.hour, t.minute + e, t.second, t.millisecond)} function ys(i) {var t, e; const s = qr.exec(i); return s ? { year:ct(s[1]), month:ct(s[2], 1) - 1, day:ct(s[3], 1), hour:ct(s[4]), minute:ct(s[5]), second:ct(s[6]), millisecond:s[7] ? ct(s[7].substring(0, 3)) : 0, precision:(t = (e = s[7]) == null ? void 0 : e.length) != null ? t : void 0, z:s[8] || void 0, plusMinus:s[9] || void 0, hourOffset:ct(s[10]), minuteOffset:ct(s[11]) } : null} function ct(i, t = 0) {return Number(i) || t} let Xr = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, Qr = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i, Jr = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Zr = '^\\d{4}-\\d{2}-\\d{2}', to = '\\d{2}:\\d{2}:\\d{2}', eo = '(([+-]\\d{2}(:?\\d{2})?)|Z)', so = new RegExp(`${Zr}T${to}(\\.\\d+)?${eo}$`), io = i=>Ct(i) || i === i.trim(), no = {}.toString(); function _n() {return new En} class En extends Et {constructor() {super({ type:'string', check(t) {return t instanceof String && (t = t.valueOf()), typeof t == 'string'} }), this.withMutation(()=>{this.transform((t, e, s)=>{if (!s.spec.coerce || s.isType(t) || Array.isArray(t)) return t; const n = t != null && t.toString ? t.toString() : t; return n === no ? t : n})})}required(t) {return super.required(t).withMutation(e=>e.test({ message:t || it.required, name:'required', skipAbsent:!0, test:s=>!!s.length }))}notRequired() {return super.notRequired().withMutation(t=>(t.tests = t.tests.filter(e=>e.OPTIONS.name !== 'required'), t))}length(t, e = H.length) {return this.test({ message:e, name:'length', exclusive:!0, params:{ length:t }, skipAbsent:!0, test(s) {return s.length === this.resolve(t)} })}min(t, e = H.min) {return this.test({ message:e, name:'min', exclusive:!0, params:{ min:t }, skipAbsent:!0, test(s) {return s.length >= this.resolve(t)} })}max(t, e = H.max) {return this.test({ name:'max', exclusive:!0, message:e, params:{ max:t }, skipAbsent:!0, test(s) {return s.length <= this.resolve(t)} })}matches(t, e) {let s = !1, n, r; return e && (typeof e == 'object' ? { excludeEmptyString:s = !1, message:n, name:r } = e : n = e), this.test({ name:r || 'matches', message:n || H.matches, params:{ regex:t }, skipAbsent:!0, test:o=>o === '' && s || o.search(t) !== -1 })}email(t = H.email) {return this.matches(Xr, { name:'email', message:t, excludeEmptyString:!0 })}url(t = H.url) {return this.matches(Qr, { name:'url', message:t, excludeEmptyString:!0 })}uuid(t = H.uuid) {return this.matches(Jr, { name:'uuid', message:t, excludeEmptyString:!1 })}datetime(t) {let e = '', s, n; return t && (typeof t == 'object' ? { message:e = '', allowOffset:s = !1, precision:n = void 0 } = t : e = t), this.matches(so, { name:'datetime', message:e || H.datetime, excludeEmptyString:!0 }).test({ name:'datetime_offset', message:e || H.datetime_offset, params:{ allowOffset:s }, skipAbsent:!0, test:r=>{if (!r || s) return !0; const o = ys(r); return o ? !!o.z : !1} }).test({ name:'datetime_precision', message:e || H.datetime_precision, params:{ precision:n }, skipAbsent:!0, test:r=>{if (!r || n == null) return !0; const o = ys(r); return o ? o.precision === n : !1} })}ensure() {return this.default('').transform(t=>t === null ? '' : t)}trim(t = H.trim) {return this.transform(e=>e != null ? e.trim() : e).test({ message:t, name:'trim', test:io })}lowercase(t = H.lowercase) {return this.transform(e=>Ct(e) ? e : e.toLowerCase()).test({ message:t, name:'string_case', exclusive:!0, skipAbsent:!0, test:e=>Ct(e) || e === e.toLowerCase() })}uppercase(t = H.uppercase) {return this.transform(e=>Ct(e) ? e : e.toUpperCase()).test({ message:t, name:'string_case', exclusive:!0, skipAbsent:!0, test:e=>Ct(e) || e === e.toUpperCase() })}}_n.prototype = En.prototype; let ro = new Date(''), oo = i=>Object.prototype.toString.call(i) === '[object Date]'; class Ls extends Et {constructor() {super({ type:'date', check(t) {return oo(t) && !isNaN(t.getTime())} }), this.withMutation(()=>{this.transform((t, e, s)=>!s.spec.coerce || s.isType(t) || t === null ? t : (t = Gr(t), isNaN(t) ? Ls.INVALID_DATE : new Date(t)))})}prepareParam(t, e) {let s; if (pe.isRef(t))s = t; else {let n = this.cast(t); if (!this._typeCheck(n)) throw new TypeError(`\`${e}\` must be a Date or a value that can be \`cast()\` to a Date`); s = n} return s}min(t, e = bs.min) {let s = this.prepareParam(t, 'min'); return this.test({ message:e, name:'min', exclusive:!0, params:{ min:t }, skipAbsent:!0, test(n) {return n >= this.resolve(s)} })}max(t, e = bs.max) {let s = this.prepareParam(t, 'max'); return this.test({ message:e, name:'max', exclusive:!0, params:{ max:t }, skipAbsent:!0, test(n) {return n <= this.resolve(s)} })}}Ls.INVALID_DATE = ro; function ao(i) {Object.keys(i).forEach(t=>{Object.keys(i[t]).forEach(e=>{Wr[t][e] = i[t][e]})})} const O = i=>typeof i == 'string', ne = ()=>{let i, t; const e = new Promise((s, n)=>{i = s, t = n}); return e.resolve = i, e.reject = t, e}, ui = i=>i == null ? '' : '' + i, lo = (i, t, e)=>{i.forEach(s=>{t[s] && (e[s] = t[s])})}, co = /###/g, hi = i=>i && i.indexOf('###') > -1 ? i.replace(co, '.') : i, fi = i=>!i || O(i), le = (i, t, e)=>{const s = O(t) ? t.split('.') : t; let n = 0; for (;n < s.length - 1;) {if (fi(i)) return {}; const r = hi(s[n]); !i[r] && e && (i[r] = new e), Object.prototype.hasOwnProperty.call(i, r) ? i = i[r] : i = {}, ++n} return fi(i) ? {} : { obj:i, k:hi(s[n]) }}, di = (i, t, e)=>{const { obj:s, k:n } = le(i, t, Object); if (s !== void 0 || t.length === 1) {s[n] = e; return} let r = t[t.length - 1], o = t.slice(0, t.length - 1), a = le(i, o, Object); for (;a.obj === void 0 && o.length;)r = `${o[o.length - 1]}.${r}`, o = o.slice(0, o.length - 1), a = le(i, o, Object), a?.obj && typeof a.obj[`${a.k}.${r}`] < 'u' && (a.obj = void 0); a.obj[`${a.k}.${r}`] = e}, uo = (i, t, e, s)=>{const { obj:n, k:r } = le(i, t, Object); n[r] = n[r] || [], n[r].push(e)}, Fe = (i, t)=>{const { obj:e, k:s } = le(i, t); if (e && Object.prototype.hasOwnProperty.call(e, s)) return e[s]}, ho = (i, t, e)=>{const s = Fe(i, e); return s !== void 0 ? s : Fe(t, e)}, vn = (i, t, e)=>{for (const s in t)s !== '__proto__' && s !== 'constructor' && (s in i ? O(i[s]) || i[s] instanceof String || O(t[s]) || t[s] instanceof String ? e && (i[s] = t[s]) : vn(i[s], t[s], e) : i[s] = t[s]); return i}, Mt = i=>i.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&'); var fo = { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', '\'':'&#39;', '/':'&#x2F;' }; const po = i=>O(i) ? i.replace(/[&<>"'\/]/g, t=>fo[t]) : i; class go {constructor(t) {this.capacity = t, this.regExpMap = new Map, this.regExpQueue = []}getRegExp(t) {const e = this.regExpMap.get(t); if (e !== void 0) return e; const s = new RegExp(t); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, s), this.regExpQueue.push(t), s}} const mo = [' ', ',', '?', '!', ';'], _o = new go(20), Eo = (i, t, e)=>{t = t || '', e = e || ''; const s = mo.filter(o=>t.indexOf(o) < 0 && e.indexOf(o) < 0); if (s.length === 0) return !0; const n = _o.getRegExp(`(${s.map(o=>o === '?' ? '\\?' : o).join('|')})`); let r = !n.test(i); if (!r) {const o = i.indexOf(e); o > 0 && !n.test(i.substring(0, o)) && (r = !0)} return r}, Ts = (i, t, e = '.')=>{if (!i) return; if (i[t]) return Object.prototype.hasOwnProperty.call(i, t) ? i[t] : void 0; const s = t.split(e); let n = i; for (let r = 0; r < s.length;) {if (!n || typeof n != 'object') return; let o, a = ''; for (let l = r; l < s.length; ++l) if (l !== r && (a += e), a += s[l], o = n[a], o !== void 0) {if (['string', 'number', 'boolean'].indexOf(typeof o) > -1 && l < s.length - 1) continue; r += l - r + 1; break}n = o} return n}, he = i=>i?.replace('_', '-'), vo = { type:'logger', log(i) {this.output('log', i)}, warn(i) {this.output('warn', i)}, error(i) {this.output('error', i)}, output(i, t) {console?.[i]?.apply?.(console, t)} }; class Me {constructor(t, e = {}) {this.init(t, e)}init(t, e = {}) {this.prefix = e.prefix || 'i18next:', this.logger = t || vo, this.options = e, this.debug = e.debug}log(...t) {return this.forward(t, 'log', '', !0)}warn(...t) {return this.forward(t, 'warn', '', !0)}error(...t) {return this.forward(t, 'error', '')}deprecate(...t) {return this.forward(t, 'warn', 'WARNING DEPRECATED: ', !0)}forward(t, e, s, n) {return n && !this.debug ? null : (O(t[0]) && (t[0] = `${s}${this.prefix} ${t[0]}`), this.logger[e](t))}create(t) {return new Me(this.logger, { prefix:`${this.prefix}:${t}:`, ...this.options })}clone(t) {return t = t || this.options, t.prefix = t.prefix || this.prefix, new Me(this.logger, t)}} var nt = new Me; class We {constructor() {this.observers = {}}on(t, e) {return t.split(' ').forEach(s=>{this.observers[s] || (this.observers[s] = new Map); const n = this.observers[s].get(e) || 0; this.observers[s].set(e, n + 1)}), this}off(t, e) {if (this.observers[t]) {if (!e) {delete this.observers[t]; return} this.observers[t].delete(e)}}emit(t, ...e) {this.observers[t] && Array.from(this.observers[t].entries()).forEach(([n, r])=>{for (let o = 0; o < r; o++)n(...e)}), this.observers['*'] && Array.from(this.observers['*'].entries()).forEach(([n, r])=>{for (let o = 0; o < r; o++)n.apply(n, [t, ...e])})}} class pi extends We {constructor(t, e = { ns:['translation'], defaultNS:'translation' }) {super(), this.data = t || {}, this.options = e, this.options.keySeparator === void 0 && (this.options.keySeparator = '.'), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)}addNamespaces(t) {this.options.ns.indexOf(t) < 0 && this.options.ns.push(t)}removeNamespaces(t) {const e = this.options.ns.indexOf(t); e > -1 && this.options.ns.splice(e, 1)}getResource(t, e, s, n = {}) {const r = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator, o = n.ignoreJSONStructure !== void 0 ? n.ignoreJSONStructure : this.options.ignoreJSONStructure; let a; t.indexOf('.') > -1 ? a = t.split('.') : (a = [t, e], s && (Array.isArray(s) ? a.push(...s) : O(s) && r ? a.push(...s.split(r)) : a.push(s))); const l = Fe(this.data, a); return !l && !e && !s && t.indexOf('.') > -1 && (t = a[0], e = a[1], s = a.slice(2).join('.')), l || !o || !O(s) ? l : Ts(this.data?.[t]?.[e], s, r)}addResource(t, e, s, n, r = { silent:!1 }) {const o = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator; let a = [t, e]; s && (a = a.concat(o ? s.split(o) : s)), t.indexOf('.') > -1 && (a = t.split('.'), n = e, e = a[1]), this.addNamespaces(e), di(this.data, a, n), r.silent || this.emit('added', t, e, s, n)}addResources(t, e, s, n = { silent:!1 }) {for (const r in s)(O(s[r]) || Array.isArray(s[r])) && this.addResource(t, e, r, s[r], { silent:!0 }); n.silent || this.emit('added', t, e, s)}addResourceBundle(t, e, s, n, r, o = { silent:!1, skipCopy:!1 }) {let a = [t, e]; t.indexOf('.') > -1 && (a = t.split('.'), n = s, s = e, e = a[1]), this.addNamespaces(e); let l = Fe(this.data, a) || {}; o.skipCopy || (s = JSON.parse(JSON.stringify(s))), n ? vn(l, s, r) : l = { ...l, ...s }, di(this.data, a, l), o.silent || this.emit('added', t, e, s)}removeResourceBundle(t, e) {this.hasResourceBundle(t, e) && delete this.data[t][e], this.removeNamespaces(e), this.emit('removed', t, e)}hasResourceBundle(t, e) {return this.getResource(t, e) !== void 0}getResourceBundle(t, e) {return e || (e = this.options.defaultNS), this.getResource(t, e)}getDataByLanguage(t) {return this.data[t]}hasLanguageSomeTranslations(t) {const e = this.getDataByLanguage(t); return !!(e && Object.keys(e) || []).find(n=>e[n] && Object.keys(e[n]).length > 0)}toJSON() {return this.data}} var bn = { processors:{}, addPostProcessor(i) {this.processors[i.name] = i}, handle(i, t, e, s, n) {return i.forEach(r=>{t = this.processors[r]?.process(t, e, s, n) ?? t}), t} }; const yn = Symbol('i18next/PATH_KEY'); function bo() {const i = [], t = Object.create(null); let e; return t.get = (s, n)=>(e?.revoke?.(), n === yn ? i : (i.push(n), e = Proxy.revocable(s, t), e.proxy)), Proxy.revocable(Object.create(null), t).proxy} function ws(i, t) {const { [yn]:e } = i(bo()); return e.join(t?.keySeparator ?? '.')} const gi = {}, mi = i=>!O(i) && typeof i != 'boolean' && typeof i != 'number'; class Ve extends We {constructor(t, e = {}) {super(), lo(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], t, this), this.options = e, this.options.keySeparator === void 0 && (this.options.keySeparator = '.'), this.logger = nt.create('translator')}changeLanguage(t) {t && (this.language = t)}exists(t, e = { interpolation:{} }) {const s = { ...e }; return t == null ? !1 : this.resolve(t, s)?.res !== void 0}extractFromKey(t, e) {let s = e.nsSeparator !== void 0 ? e.nsSeparator : this.options.nsSeparator; s === void 0 && (s = ':'); const n = e.keySeparator !== void 0 ? e.keySeparator : this.options.keySeparator; let r = e.ns || this.options.defaultNS || []; const o = s && t.indexOf(s) > -1, a = !this.options.userDefinedKeySeparator && !e.keySeparator && !this.options.userDefinedNsSeparator && !e.nsSeparator && !Eo(t, s, n); if (o && !a) {const l = t.match(this.interpolator.nestingRegexp); if (l && l.length > 0) return { key:t, namespaces:O(r) ? [r] : r }; const c = t.split(s); (s !== n || s === n && this.options.ns.indexOf(c[0]) > -1) && (r = c.shift()), t = c.join(n)} return { key:t, namespaces:O(r) ? [r] : r }}translate(t, e, s) {let n = typeof e == 'object' ? { ...e } : e; if (typeof n != 'object' && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == 'object' && (n = { ...n }), n || (n = {}), t == null) return ''; typeof t == 'function' && (t = ws(t, { ...this.options, ...n })), Array.isArray(t) || (t = [String(t)]); const r = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails, o = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator, { key:a, namespaces:l } = this.extractFromKey(t[t.length - 1], n), c = l[l.length - 1]; let u = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator; u === void 0 && (u = ':'); const h = n.lng || this.language, p = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if (h?.toLowerCase() === 'cimode') return p ? r ? { res:`${c}${u}${a}`, usedKey:a, exactUsedKey:a, usedLng:h, usedNS:c, usedParams:this.getUsedParamsDetails(n) } : `${c}${u}${a}` : r ? { res:a, usedKey:a, exactUsedKey:a, usedLng:h, usedNS:c, usedParams:this.getUsedParamsDetails(n) } : a; const f = this.resolve(t, n); let m = f?.res; const _ = f?.usedKey || a, b = f?.exactUsedKey || a, g = ['[object Number]', '[object Function]', '[object RegExp]'], E = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays, S = !this.i18nFormat || this.i18nFormat.handleAsObject, v = n.count !== void 0 && !O(n.count), y = Ve.hasDefaultValue(n), T = v ? this.pluralResolver.getSuffix(h, n.count, n) : '', A = n.ordinal && v ? this.pluralResolver.getSuffix(h, n.count, { ordinal:!1 }) : '', N = v && !n.ordinal && n.count === 0, x = N && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${T}`] || n[`defaultValue${A}`] || n.defaultValue; let $ = m; S && !m && y && ($ = x); const C = mi($), R = Object.prototype.toString.apply($); if (S && $ && C && g.indexOf(R) < 0 && !(O(E) && Array.isArray($))) {if (!n.returnObjects && !this.options.returnObjects) {this.options.returnedObjectHandler || this.logger.warn('accessing an object - but returnObjects options is not enabled!'); const L = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(_, $, { ...n, ns:l }) : `key '${a} (${this.language})' returned an object instead of string.`; return r ? (f.res = L, f.usedParams = this.getUsedParamsDetails(n), f) : L} if (o) {const L = Array.isArray($), P = L ? [] : {}, tt = L ? b : _; for (const D in $) if (Object.prototype.hasOwnProperty.call($, D)) {const I = `${tt}${o}${D}`; y && !m ? P[D] = this.translate(I, { ...n, defaultValue:mi(x) ? x[D] : void 0, joinArrays:!1, ns:l }) : P[D] = this.translate(I, { ...n, joinArrays:!1, ns:l }), P[D] === I && (P[D] = $[D])}m = P}} else if (S && O(E) && Array.isArray(m))m = m.join(E), m && (m = this.extendTranslation(m, t, n, s)); else {let L = !1, P = !1; !this.isValidLookup(m) && y && (L = !0, m = x), this.isValidLookup(m) || (P = !0, m = a); const D = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && P ? void 0 : m, I = y && x !== m && this.options.updateMissing; if (P || L || I) {if (this.logger.log(I ? 'updateKey' : 'missingKey', h, c, a, I ? x : m), o) {const k = this.resolve(a, { ...n, keySeparator:!1 }); k && k.res && this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.')} let et = []; const q = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language); if (this.options.saveMissingTo === 'fallback' && q && q[0]) for (let k = 0; k < q.length; k++)et.push(q[k]); else this.options.saveMissingTo === 'all' ? et = this.languageUtils.toResolveHierarchy(n.lng || this.language) : et.push(n.lng || this.language); const Ot = (k, B, st)=>{const lt = y && st !== m ? st : D; this.options.missingKeyHandler ? this.options.missingKeyHandler(k, c, B, lt, I, n) : this.backendConnector?.saveMissing && this.backendConnector.saveMissing(k, c, B, lt, I, n), this.emit('missingKey', k, c, B, m)}; this.options.saveMissing && (this.options.saveMissingPlurals && v ? et.forEach(k=>{const B = this.pluralResolver.getSuffixes(k, n); N && n[`defaultValue${this.options.pluralSeparator}zero`] && B.indexOf(`${this.options.pluralSeparator}zero`) < 0 && B.push(`${this.options.pluralSeparator}zero`), B.forEach(st=>{Ot([k], a + st, n[`defaultValue${st}`] || x)})}) : Ot(et, a, x))}m = this.extendTranslation(m, t, n, f, s), P && m === a && this.options.appendNamespaceToMissingKey && (m = `${c}${u}${a}`), (P || L) && this.options.parseMissingKeyHandler && (m = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}${u}${a}` : a, L ? m : void 0, n))} return r ? (f.res = m, f.usedParams = this.getUsedParamsDetails(n), f) : m}extendTranslation(t, e, s, n, r) {if (this.i18nFormat?.parse)t = this.i18nFormat.parse(t, { ...this.options.interpolation.defaultVariables, ...s }, s.lng || this.language || n.usedLng, n.usedNS, n.usedKey, { resolved:n }); else if (!s.skipInterpolation) {s.interpolation && this.interpolator.init({ ...s, interpolation:{ ...this.options.interpolation, ...s.interpolation } }); const l = O(t) && (s?.interpolation?.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let c; if (l) {const h = t.match(this.interpolator.nestingRegexp); c = h && h.length} let u = s.replace && !O(s.replace) ? s.replace : s; if (this.options.interpolation.defaultVariables && (u = { ...this.options.interpolation.defaultVariables, ...u }), t = this.interpolator.interpolate(t, u, s.lng || this.language || n.usedLng, s), l) {const h = t.match(this.interpolator.nestingRegexp), p = h && h.length; c < p && (s.nest = !1)}!s.lng && n && n.res && (s.lng = this.language || n.usedLng), s.nest !== !1 && (t = this.interpolator.nest(t, (...h)=>r?.[0] === h[0] && !s.context ? (this.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${e[0]}`), null) : this.translate(...h, e), s)), s.interpolation && this.interpolator.reset()} const o = s.postProcess || this.options.postProcess, a = O(o) ? [o] : o; return t != null && a?.length && s.applyPostProcessor !== !1 && (t = bn.handle(a, t, e, this.options && this.options.postProcessPassResolved ? { i18nResolved:{ ...n, usedParams:this.getUsedParamsDetails(s) }, ...s } : s, this)), t}resolve(t, e = {}) {let s, n, r, o, a; return O(t) && (t = [t]), t.forEach(l=>{if (this.isValidLookup(s)) return; const c = this.extractFromKey(l, e), u = c.key; n = u; let h = c.namespaces; this.options.fallbackNS && (h = h.concat(this.options.fallbackNS)); const p = e.count !== void 0 && !O(e.count), f = p && !e.ordinal && e.count === 0, m = e.context !== void 0 && (O(e.context) || typeof e.context == 'number') && e.context !== '', _ = e.lngs ? e.lngs : this.languageUtils.toResolveHierarchy(e.lng || this.language, e.fallbackLng); h.forEach(b=>{this.isValidLookup(s) || (a = b, !gi[`${_[0]}-${b}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(a) && (gi[`${_[0]}-${b}`] = !0, this.logger.warn(`key "${n}" for languages "${_.join(', ')}" won't get resolved as namespace "${a}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!')), _.forEach(g=>{if (this.isValidLookup(s)) return; o = g; const E = [u]; if (this.i18nFormat?.addLookupKeys) this.i18nFormat.addLookupKeys(E, u, g, b, e); else {let v; p && (v = this.pluralResolver.getSuffix(g, e.count, e)); const y = `${this.options.pluralSeparator}zero`, T = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (p && (e.ordinal && v.indexOf(T) === 0 && E.push(u + v.replace(T, this.options.pluralSeparator)), E.push(u + v), f && E.push(u + y)), m) {const A = `${u}${this.options.contextSeparator || '_'}${e.context}`; E.push(A), p && (e.ordinal && v.indexOf(T) === 0 && E.push(A + v.replace(T, this.options.pluralSeparator)), E.push(A + v), f && E.push(A + y))}} let S; for (;S = E.pop();) this.isValidLookup(s) || (r = S, s = this.getResource(g, b, S, e))}))})}), { res:s, usedKey:n, exactUsedKey:r, usedLng:o, usedNS:a }}isValidLookup(t) {return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === '')}getResource(t, e, s, n = {}) {return this.i18nFormat?.getResource ? this.i18nFormat.getResource(t, e, s, n) : this.resourceStore.getResource(t, e, s, n)}getUsedParamsDetails(t = {}) {const e = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'], s = t.replace && !O(t.replace); let n = s ? t.replace : t; if (s && typeof t.count < 'u' && (n.count = t.count), this.options.interpolation.defaultVariables && (n = { ...this.options.interpolation.defaultVariables, ...n }), !s) {n = { ...n }; for (const r of e) delete n[r]} return n} static hasDefaultValue(t) {const e = 'defaultValue'; for (const s in t) if (Object.prototype.hasOwnProperty.call(t, s) && e === s.substring(0, e.length) && t[s] !== void 0) return !0; return !1}} class _i {constructor(t) {this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = nt.create('languageUtils')}getScriptPartFromCode(t) {if (t = he(t), !t || t.indexOf('-') < 0) return null; const e = t.split('-'); return e.length === 2 || (e.pop(), e[e.length - 1].toLowerCase() === 'x') ? null : this.formatLanguageCode(e.join('-'))}getLanguagePartFromCode(t) {if (t = he(t), !t || t.indexOf('-') < 0) return t; const e = t.split('-'); return this.formatLanguageCode(e[0])}formatLanguageCode(t) {if (O(t) && t.indexOf('-') > -1) {let e; try {e = Intl.getCanonicalLocales(t)[0]} catch {} return e && this.options.lowerCaseLng && (e = e.toLowerCase()), e || (this.options.lowerCaseLng ? t.toLowerCase() : t)} return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t}isSupportedCode(t) {return (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1}getBestMatchFromCodes(t) {if (!t) return null; let e; return t.forEach(s=>{if (e) return; const n = this.formatLanguageCode(s); (!this.options.supportedLngs || this.isSupportedCode(n)) && (e = n)}), !e && this.options.supportedLngs && t.forEach(s=>{if (e) return; const n = this.getScriptPartFromCode(s); if (this.isSupportedCode(n)) return e = n; const r = this.getLanguagePartFromCode(s); if (this.isSupportedCode(r)) return e = r; e = this.options.supportedLngs.find(o=>{if (o === r) return o; if (!(o.indexOf('-') < 0 && r.indexOf('-') < 0) && (o.indexOf('-') > 0 && r.indexOf('-') < 0 && o.substring(0, o.indexOf('-')) === r || o.indexOf(r) === 0 && r.length > 1)) return o})}), e || (e = this.getFallbackCodes(this.options.fallbackLng)[0]), e}getFallbackCodes(t, e) {if (!t) return []; if (typeof t == 'function' && (t = t(e)), O(t) && (t = [t]), Array.isArray(t)) return t; if (!e) return t.default || []; let s = t[e]; return s || (s = t[this.getScriptPartFromCode(e)]), s || (s = t[this.formatLanguageCode(e)]), s || (s = t[this.getLanguagePartFromCode(e)]), s || (s = t.default), s || []}toResolveHierarchy(t, e) {const s = this.getFallbackCodes((e === !1 ? [] : e) || this.options.fallbackLng || [], t), n = [], r = o=>{o && (this.isSupportedCode(o) ? n.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`))}; return O(t) && (t.indexOf('-') > -1 || t.indexOf('_') > -1) ? (this.options.load !== 'languageOnly' && r(this.formatLanguageCode(t)), this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly' && r(this.getScriptPartFromCode(t)), this.options.load !== 'currentOnly' && r(this.getLanguagePartFromCode(t))) : O(t) && r(this.formatLanguageCode(t)), s.forEach(o=>{n.indexOf(o) < 0 && r(this.formatLanguageCode(o))}), n}} const Ei = { zero:0, one:1, two:2, few:3, many:4, other:5 }, vi = { select:i=>i === 1 ? 'one' : 'other', resolvedOptions:()=>({ pluralCategories:['one', 'other'] }) }; class yo {constructor(t, e = {}) {this.languageUtils = t, this.options = e, this.logger = nt.create('pluralResolver'), this.pluralRulesCache = {}}addRule(t, e) {this.rules[t] = e}clearCache() {this.pluralRulesCache = {}}getRule(t, e = {}) {const s = he(t === 'dev' ? 'en' : t), n = e.ordinal ? 'ordinal' : 'cardinal', r = JSON.stringify({ cleanedCode:s, type:n }); if (r in this.pluralRulesCache) return this.pluralRulesCache[r]; let o; try {o = new Intl.PluralRules(s, { type:n })} catch {if (!Intl) return this.logger.error('No Intl support, please use an Intl polyfill!'), vi; if (!t.match(/-|_/)) return vi; const l = this.languageUtils.getLanguagePartFromCode(t); o = this.getRule(l, e)} return this.pluralRulesCache[r] = o, o}needsPlural(t, e = {}) {let s = this.getRule(t, e); return s || (s = this.getRule('dev', e)), s?.resolvedOptions().pluralCategories.length > 1}getPluralFormsOfKey(t, e, s = {}) {return this.getSuffixes(t, s).map(n=>`${e}${n}`)}getSuffixes(t, e = {}) {let s = this.getRule(t, e); return s || (s = this.getRule('dev', e)), s ? s.resolvedOptions().pluralCategories.sort((n, r)=>Ei[n] - Ei[r]).map(n=>`${this.options.prepend}${e.ordinal ? `ordinal${this.options.prepend}` : ''}${n}`) : []}getSuffix(t, e, s = {}) {const n = this.getRule(t, s); return n ? `${this.options.prepend}${s.ordinal ? `ordinal${this.options.prepend}` : ''}${n.select(e)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix('dev', e, s))}} const bi = (i, t, e, s = '.', n = !0)=>{let r = ho(i, t, e); return !r && n && O(e) && (r = Ts(i, e, s), r === void 0 && (r = Ts(t, e, s))), r}, is = i=>i.replace(/\$/g, '$$$$'); class To {constructor(t = {}) {this.logger = nt.create('interpolator'), this.options = t, this.format = t?.interpolation?.format || (e=>e), this.init(t)}init(t = {}) {t.interpolation || (t.interpolation = { escapeValue:!0 }); const { escape:e, escapeValue:s, useRawValueToEscape:n, prefix:r, prefixEscaped:o, suffix:a, suffixEscaped:l, formatSeparator:c, unescapeSuffix:u, unescapePrefix:h, nestingPrefix:p, nestingPrefixEscaped:f, nestingSuffix:m, nestingSuffixEscaped:_, nestingOptionsSeparator:b, maxReplaces:g, alwaysFormat:E } = t.interpolation; this.escape = e !== void 0 ? e : po, this.escapeValue = s !== void 0 ? s : !0, this.useRawValueToEscape = n !== void 0 ? n : !1, this.prefix = r ? Mt(r) : o || '{{', this.suffix = a ? Mt(a) : l || '}}', this.formatSeparator = c || ',', this.unescapePrefix = u ? '' : h || '-', this.unescapeSuffix = this.unescapePrefix ? '' : u || '', this.nestingPrefix = p ? Mt(p) : f || Mt('$t('), this.nestingSuffix = m ? Mt(m) : _ || Mt(')'), this.nestingOptionsSeparator = b || ',', this.maxReplaces = g || 1e3, this.alwaysFormat = E !== void 0 ? E : !1, this.resetRegExp()}reset() {this.options && this.init(this.options)}resetRegExp() {const t = (e, s)=>e?.source === s ? (e.lastIndex = 0, e) : new RegExp(s, 'g'); this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`)}interpolate(t, e, s, n) {let r, o, a; const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = f=>{if (f.indexOf(this.formatSeparator) < 0) {const g = bi(e, l, f, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(g, void 0, s, { ...n, ...e, interpolationkey:f }) : g} const m = f.split(this.formatSeparator), _ = m.shift().trim(), b = m.join(this.formatSeparator).trim(); return this.format(bi(e, l, _, this.options.keySeparator, this.options.ignoreJSONStructure), b, s, { ...n, ...e, interpolationkey:_ })}; this.resetRegExp(); const u = n?.missingInterpolationHandler || this.options.missingInterpolationHandler, h = n?.interpolation?.skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex:this.regexpUnescape, safeValue:f=>is(f) }, { regex:this.regexp, safeValue:f=>this.escapeValue ? is(this.escape(f)) : is(f) }].forEach(f=>{for (a = 0; r = f.regex.exec(t);) {const m = r[1].trim(); if (o = c(m), o === void 0) if (typeof u == 'function') {const b = u(t, r, n); o = O(b) ? b : ''} else if (n && Object.prototype.hasOwnProperty.call(n, m))o = ''; else if (h) {o = r[0]; continue} else this.logger.warn(`missed to pass in variable ${m} for interpolating ${t}`), o = ''; else !O(o) && !this.useRawValueToEscape && (o = ui(o)); const _ = f.safeValue(o); if (t = t.replace(r[0], _), h ? (f.regex.lastIndex += o.length, f.regex.lastIndex -= r[0].length) : f.regex.lastIndex = 0, a++, a >= this.maxReplaces) break}}), t}nest(t, e, s = {}) {let n, r, o; const a = (l, c)=>{const u = this.nestingOptionsSeparator; if (l.indexOf(u) < 0) return l; const h = l.split(new RegExp(`${u}[ ]*{`)); let p = `{${h[1]}`; l = h[0], p = this.interpolate(p, o); const f = p.match(/'/g), m = p.match(/"/g); ((f?.length ?? 0) % 2 === 0 && !m || m.length % 2 !== 0) && (p = p.replace(/'/g, '"')); try {o = JSON.parse(p), c && (o = { ...c, ...o })} catch (_) {return this.logger.warn(`failed parsing options string in nesting for key ${l}`, _), `${l}${u}${p}`} return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, l}; for (;n = this.nestingRegexp.exec(t);) {let l = []; o = { ...s }, o = o.replace && !O(o.replace) ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue; const c = /{.*}/.test(n[1]) ? n[1].lastIndexOf('}') + 1 : n[1].indexOf(this.formatSeparator); if (c !== -1 && (l = n[1].slice(c).split(this.formatSeparator).map(u=>u.trim()).filter(Boolean), n[1] = n[1].slice(0, c)), r = e(a.call(this, n[1].trim(), o), o), r && n[0] === t && !O(r)) return r; O(r) || (r = ui(r)), r || (this.logger.warn(`missed to resolve ${n[1]} for nesting ${t}`), r = ''), l.length && (r = l.reduce((u, h)=>this.format(u, h, s.lng, { ...s, interpolationkey:n[1].trim() }), r.trim())), t = t.replace(n[0], r), this.regexp.lastIndex = 0} return t}} const wo = i=>{let t = i.toLowerCase().trim(); const e = {}; if (i.indexOf('(') > -1) {const s = i.split('('); t = s[0].toLowerCase().trim(); const n = s[1].substring(0, s[1].length - 1); t === 'currency' && n.indexOf(':') < 0 ? e.currency || (e.currency = n.trim()) : t === 'relativetime' && n.indexOf(':') < 0 ? e.range || (e.range = n.trim()) : n.split(';').forEach(o=>{if (o) {const [a, ...l] = o.split(':'), c = l.join(':').trim().replace(/^'+|'+$/g, ''), u = a.trim(); e[u] || (e[u] = c), c === 'false' && (e[u] = !1), c === 'true' && (e[u] = !0), isNaN(c) || (e[u] = parseInt(c, 10))}})} return { formatName:t, formatOptions:e }}, yi = i=>{const t = {}; return (e, s, n)=>{let r = n; n && n.interpolationkey && n.formatParams && n.formatParams[n.interpolationkey] && n[n.interpolationkey] && (r = { ...r, [n.interpolationkey]:void 0 }); const o = s + JSON.stringify(r); let a = t[o]; return a || (a = i(he(s), n), t[o] = a), a(e)}}, So = i=>(t, e, s)=>i(he(e), s)(t); class Oo {constructor(t = {}) {this.logger = nt.create('formatter'), this.options = t, this.init(t)}init(t, e = { interpolation:{} }) {this.formatSeparator = e.interpolation.formatSeparator || ','; const s = e.cacheInBuiltFormats ? yi : So; this.formats = { number:s((n, r)=>{const o = new Intl.NumberFormat(n, { ...r }); return a=>o.format(a)}), currency:s((n, r)=>{const o = new Intl.NumberFormat(n, { ...r, style:'currency' }); return a=>o.format(a)}), datetime:s((n, r)=>{const o = new Intl.DateTimeFormat(n, { ...r }); return a=>o.format(a)}), relativetime:s((n, r)=>{const o = new Intl.RelativeTimeFormat(n, { ...r }); return a=>o.format(a, r.range || 'day')}), list:s((n, r)=>{const o = new Intl.ListFormat(n, { ...r }); return a=>o.format(a)}) }}add(t, e) {this.formats[t.toLowerCase().trim()] = e}addCached(t, e) {this.formats[t.toLowerCase().trim()] = yi(e)}format(t, e, s, n = {}) {const r = e.split(this.formatSeparator); if (r.length > 1 && r[0].indexOf('(') > 1 && r[0].indexOf(')') < 0 && r.find(a=>a.indexOf(')') > -1)) {const a = r.findIndex(l=>l.indexOf(')') > -1); r[0] = [r[0], ...r.splice(1, a)].join(this.formatSeparator)} return r.reduce((a, l)=>{const { formatName:c, formatOptions:u } = wo(l); if (this.formats[c]) {let h = a; try {const p = n?.formatParams?.[n.interpolationkey] || {}, f = p.locale || p.lng || n.locale || n.lng || s; h = this.formats[c](a, f, { ...u, ...n, ...p })} catch (p) {this.logger.warn(p)} return h} else this.logger.warn(`there was no format function for ${c}`); return a}, t)}} const Ao = (i, t)=>{i.pending[t] !== void 0 && (delete i.pending[t], i.pendingCount--)}; class xo extends We {constructor(t, e, s, n = {}) {super(), this.backend = t, this.store = e, this.services = s, this.languageUtils = s.languageUtils, this.options = n, this.logger = nt.create('backendConnector'), this.waitingReads = [], this.maxParallelReads = n.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = n.maxRetries >= 0 ? n.maxRetries : 5, this.retryTimeout = n.retryTimeout >= 1 ? n.retryTimeout : 350, this.state = {}, this.queue = [], this.backend?.init?.(s, n.backend, n)}queueLoad(t, e, s, n) {const r = {}, o = {}, a = {}, l = {}; return t.forEach(c=>{let u = !0; e.forEach(h=>{const p = `${c}|${h}`; !s.reload && this.store.hasResourceBundle(c, h) ? this.state[p] = 2 : this.state[p] < 0 || (this.state[p] === 1 ? o[p] === void 0 && (o[p] = !0) : (this.state[p] = 1, u = !1, o[p] === void 0 && (o[p] = !0), r[p] === void 0 && (r[p] = !0), l[h] === void 0 && (l[h] = !0)))}), u || (a[c] = !0)}), (Object.keys(r).length || Object.keys(o).length) && this.queue.push({ pending:o, pendingCount:Object.keys(o).length, loaded:{}, errors:[], callback:n }), { toLoad:Object.keys(r), pending:Object.keys(o), toLoadLanguages:Object.keys(a), toLoadNamespaces:Object.keys(l) }}loaded(t, e, s) {const n = t.split('|'), r = n[0], o = n[1]; e && this.emit('failedLoading', r, o, e), !e && s && this.store.addResourceBundle(r, o, s, void 0, void 0, { skipCopy:!0 }), this.state[t] = e ? -1 : 2, e && s && (this.state[t] = 0); const a = {}; this.queue.forEach(l=>{uo(l.loaded, [r], o), Ao(l, t), e && l.errors.push(e), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach(c=>{a[c] || (a[c] = {}); const u = l.loaded[c]; u.length && u.forEach(h=>{a[c][h] === void 0 && (a[c][h] = !0)})}), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback())}), this.emit('loaded', a), this.queue = this.queue.filter(l=>!l.done)}read(t, e, s, n = 0, r = this.retryTimeout, o) {if (!t.length) return o(null, {}); if (this.readingCalls >= this.maxParallelReads) {this.waitingReads.push({ lng:t, ns:e, fcName:s, tried:n, wait:r, callback:o }); return} this.readingCalls++; const a = (c, u)=>{if (this.readingCalls--, this.waitingReads.length > 0) {const h = this.waitingReads.shift(); this.read(h.lng, h.ns, h.fcName, h.tried, h.wait, h.callback)} if (c && u && n < this.maxRetries) {setTimeout(()=>{this.read.call(this, t, e, s, n + 1, r * 2, o)}, r); return}o(c, u)}, l = this.backend[s].bind(this.backend); if (l.length === 2) {try {const c = l(t, e); c && typeof c.then == 'function' ? c.then(u=>a(null, u)).catch(a) : a(null, c)} catch (c) {a(c)} return} return l(t, e, a)}prepareLoading(t, e, s = {}, n) {if (!this.backend) return this.logger.warn('No backend was added via i18next.use. Will not load resources.'), n && n(); O(t) && (t = this.languageUtils.toResolveHierarchy(t)), O(e) && (e = [e]); const r = this.queueLoad(t, e, s, n); if (!r.toLoad.length) return r.pending.length || n(), null; r.toLoad.forEach(o=>{this.loadOne(o)})}load(t, e, s) {this.prepareLoading(t, e, {}, s)}reload(t, e, s) {this.prepareLoading(t, e, { reload:!0 }, s)}loadOne(t, e = '') {const s = t.split('|'), n = s[0], r = s[1]; this.read(n, r, 'read', void 0, void 0, (o, a)=>{o && this.logger.warn(`${e}loading namespace ${r} for language ${n} failed`, o), !o && a && this.logger.log(`${e}loaded namespace ${r} for language ${n}`, a), this.loaded(t, o, a)})}saveMissing(t, e, s, n, r, o = {}, a = ()=>{}) {if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(e)) {this.logger.warn(`did not save key "${s}" as the namespace "${e}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!'); return} if (!(s == null || s === '')) {if (this.backend?.create) {const l = { ...o, isUpdate:r }, c = this.backend.create.bind(this.backend); if (c.length < 6) try {let u; c.length === 5 ? u = c(t, e, s, n, l) : u = c(t, e, s, n), u && typeof u.then == 'function' ? u.then(h=>a(null, h)).catch(a) : a(null, u)} catch (u) {a(u)} else c(t, e, s, n, a, l)}!t || !t[0] || this.store.addResource(t[0], e, s, n)}}} const Ti = ()=>({ debug:!1, initAsync:!0, ns:['translation'], defaultNS:['translation'], fallbackLng:['dev'], fallbackNS:!1, supportedLngs:!1, nonExplicitSupportedLngs:!1, load:'all', preload:!1, simplifyPluralSuffix:!0, keySeparator:'.', nsSeparator:':', pluralSeparator:'_', contextSeparator:'_', partialBundledLanguages:!1, saveMissing:!1, updateMissing:!1, saveMissingTo:'fallback', saveMissingPlurals:!0, missingKeyHandler:!1, missingInterpolationHandler:!1, postProcess:!1, postProcessPassResolved:!1, returnNull:!1, returnEmptyString:!0, returnObjects:!1, joinArrays:!1, returnedObjectHandler:!1, parseMissingKeyHandler:!1, appendNamespaceToMissingKey:!1, appendNamespaceToCIMode:!1, overloadTranslationOptionHandler:i=>{let t = {}; if (typeof i[1] == 'object' && (t = i[1]), O(i[1]) && (t.defaultValue = i[1]), O(i[2]) && (t.tDescription = i[2]), typeof i[2] == 'object' || typeof i[3] == 'object') {const e = i[3] || i[2]; Object.keys(e).forEach(s=>{t[s] = e[s]})} return t}, interpolation:{ escapeValue:!0, format:i=>i, prefix:'{{', suffix:'}}', formatSeparator:',', unescapePrefix:'-', nestingPrefix:'$t(', nestingSuffix:')', nestingOptionsSeparator:',', maxReplaces:1e3, skipOnVariables:!0 }, cacheInBuiltFormats:!0 }), wi = i=>(O(i.ns) && (i.ns = [i.ns]), O(i.fallbackLng) && (i.fallbackLng = [i.fallbackLng]), O(i.fallbackNS) && (i.fallbackNS = [i.fallbackNS]), i.supportedLngs?.indexOf?.('cimode') < 0 && (i.supportedLngs = i.supportedLngs.concat(['cimode'])), typeof i.initImmediate == 'boolean' && (i.initAsync = i.initImmediate), i), Se = ()=>{}, Co = i=>{Object.getOwnPropertyNames(Object.getPrototypeOf(i)).forEach(e=>{typeof i[e] == 'function' && (i[e] = i[e].bind(i))})}; class fe extends We {constructor(t = {}, e) {if (super(), this.options = wi(t), this.services = {}, this.logger = nt, this.modules = { external:[] }, Co(this), e && !this.isInitialized && !t.isClone) {if (!this.options.initAsync) return this.init(t, e), this; setTimeout(()=>{this.init(t, e)}, 0)}}init(t = {}, e) {this.isInitializing = !0, typeof t == 'function' && (e = t, t = {}), t.defaultNS == null && t.ns && (O(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf('translation') < 0 && (t.defaultNS = t.ns[0])); const s = Ti(); this.options = { ...s, ...this.options, ...wi(t) }, this.options.interpolation = { ...s.interpolation, ...this.options.interpolation }, t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator); const n = c=>c ? typeof c == 'function' ? new c : c : null; if (!this.options.isClone) {this.modules.logger ? nt.init(n(this.modules.logger), this.options) : nt.init(null, this.options); let c; this.modules.formatter ? c = this.modules.formatter : c = Oo; const u = new _i(this.options); this.store = new pi(this.options.resources, this.options); const h = this.services; h.logger = nt, h.resourceStore = this.store, h.languageUtils = u, h.pluralResolver = new yo(u, { prepend:this.options.pluralSeparator, simplifyPluralSuffix:this.options.simplifyPluralSuffix }), this.options.interpolation.format && this.options.interpolation.format !== s.interpolation.format && this.logger.deprecate('init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting'), c && (!this.options.interpolation.format || this.options.interpolation.format === s.interpolation.format) && (h.formatter = n(c), h.formatter.init && h.formatter.init(h, this.options), this.options.interpolation.format = h.formatter.format.bind(h.formatter)), h.interpolator = new To(this.options), h.utils = { hasLoadedNamespace:this.hasLoadedNamespace.bind(this) }, h.backendConnector = new xo(n(this.modules.backend), h.resourceStore, h, this.options), h.backendConnector.on('*', (f, ...m)=>{this.emit(f, ...m)}), this.modules.languageDetector && (h.languageDetector = n(this.modules.languageDetector), h.languageDetector.init && h.languageDetector.init(h, this.options.detection, this.options)), this.modules.i18nFormat && (h.i18nFormat = n(this.modules.i18nFormat), h.i18nFormat.init && h.i18nFormat.init(this)), this.translator = new Ve(this.services, this.options), this.translator.on('*', (f, ...m)=>{this.emit(f, ...m)}), this.modules.external.forEach(f=>{f.init && f.init(this)})} if (this.format = this.options.interpolation.format, e || (e = Se), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); c.length > 0 && c[0] !== 'dev' && (this.options.lng = c[0])}!this.services.languageDetector && !this.options.lng && this.logger.warn('init: no languageDetector is used and no lng is defined'), ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'].forEach(c=>{this[c] = (...u)=>this.store[c](...u)}), ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'].forEach(c=>{this[c] = (...u)=>(this.store[c](...u), this)}); const a = ne(), l = ()=>{const c = (u, h)=>{this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn('init: i18next is already initialized. You should call init just once!'), this.isInitialized = !0, this.options.isClone || this.logger.log('initialized', this.options), this.emit('initialized', this.options), a.resolve(h), e(u, h)}; if (this.languages && !this.isInitialized) return c(null, this.t.bind(this)); this.changeLanguage(this.options.lng, c)}; return this.options.resources || !this.options.initAsync ? l() : setTimeout(l, 0), a}loadResources(t, e = Se) {let s = e; const n = O(t) ? t : this.language; if (typeof t == 'function' && (s = t), !this.options.resources || this.options.partialBundledLanguages) {if (n?.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return s(); const r = [], o = a=>{if (!a || a === 'cimode') return; this.services.languageUtils.toResolveHierarchy(a).forEach(c=>{c !== 'cimode' && r.indexOf(c) < 0 && r.push(c)})}; n ? o(n) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(l=>o(l)), this.options.preload?.forEach?.(a=>o(a)), this.services.backendConnector.load(r, this.options.ns, a=>{!a && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), s(a)})} else s(null)}reloadResources(t, e, s) {const n = ne(); return typeof t == 'function' && (s = t, t = void 0), typeof e == 'function' && (s = e, e = void 0), t || (t = this.languages), e || (e = this.options.ns), s || (s = Se), this.services.backendConnector.reload(t, e, r=>{n.resolve(), s(r)}), n}use(t) {if (!t) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()'); if (!t.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()'); return t.type === 'backend' && (this.modules.backend = t), (t.type === 'logger' || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === 'languageDetector' && (this.modules.languageDetector = t), t.type === 'i18nFormat' && (this.modules.i18nFormat = t), t.type === 'postProcessor' && bn.addPostProcessor(t), t.type === 'formatter' && (this.modules.formatter = t), t.type === '3rdParty' && this.modules.external.push(t), this}setResolvedLanguage(t) {if (!(!t || !this.languages) && !(['cimode', 'dev'].indexOf(t) > -1)) {for (let e = 0; e < this.languages.length; e++) {const s = this.languages[e]; if (!(['cimode', 'dev'].indexOf(s) > -1) && this.store.hasLanguageSomeTranslations(s)) {this.resolvedLanguage = s; break}}!this.resolvedLanguage && this.languages.indexOf(t) < 0 && this.store.hasLanguageSomeTranslations(t) && (this.resolvedLanguage = t, this.languages.unshift(t))}}changeLanguage(t, e) {this.isLanguageChangingTo = t; const s = ne(); this.emit('languageChanging', t); const n = a=>{this.language = a, this.languages = this.services.languageUtils.toResolveHierarchy(a), this.resolvedLanguage = void 0, this.setResolvedLanguage(a)}, r = (a, l)=>{l ? this.isLanguageChangingTo === t && (n(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit('languageChanged', l), this.logger.log('languageChanged', l)) : this.isLanguageChangingTo = void 0, s.resolve((...c)=>this.t(...c)), e && e(a, (...c)=>this.t(...c))}, o = a=>{!t && !a && this.services.languageDetector && (a = []); const l = O(a) ? a : a && a[0], c = this.store.hasLanguageSomeTranslations(l) ? l : this.services.languageUtils.getBestMatchFromCodes(O(a) ? [a] : a); c && (this.language || n(c), this.translator.language || this.translator.changeLanguage(c), this.services.languageDetector?.cacheUserLanguage?.(c)), this.loadResources(c, u=>{r(u, c)})}; return !t && this.services.languageDetector && !this.services.languageDetector.async ? o(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(o) : this.services.languageDetector.detect(o) : o(t), s}getFixedT(t, e, s) {const n = (r, o, ...a)=>{let l; typeof o != 'object' ? l = this.options.overloadTranslationOptionHandler([r, o].concat(a)) : l = { ...o }, l.lng = l.lng || n.lng, l.lngs = l.lngs || n.lngs, l.ns = l.ns || n.ns, l.keyPrefix !== '' && (l.keyPrefix = l.keyPrefix || s || n.keyPrefix); const c = this.options.keySeparator || '.'; let u; return l.keyPrefix && Array.isArray(r) ? u = r.map(h=>(typeof h == 'function' && (h = ws(h, { ...this.options, ...o })), `${l.keyPrefix}${c}${h}`)) : (typeof r == 'function' && (r = ws(r, { ...this.options, ...o })), u = l.keyPrefix ? `${l.keyPrefix}${c}${r}` : r), this.t(u, l)}; return O(t) ? n.lng = t : n.lngs = t, n.ns = e, n.keyPrefix = s, n}t(...t) {return this.translator?.translate(...t)}exists(...t) {return this.translator?.exists(...t)}setDefaultNamespace(t) {this.options.defaultNS = t}hasLoadedNamespace(t, e = {}) {if (!this.isInitialized) return this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages), !1; const s = e.lng || this.resolvedLanguage || this.languages[0], n = this.options ? this.options.fallbackLng : !1, r = this.languages[this.languages.length - 1]; if (s.toLowerCase() === 'cimode') return !0; const o = (a, l)=>{const c = this.services.backendConnector.state[`${a}|${l}`]; return c === -1 || c === 0 || c === 2}; if (e.precheck) {const a = e.precheck(this, o); if (a !== void 0) return a} return !!(this.hasResourceBundle(s, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(s, t) && (!n || o(r, t)))}loadNamespaces(t, e) {const s = ne(); return this.options.ns ? (O(t) && (t = [t]), t.forEach(n=>{this.options.ns.indexOf(n) < 0 && this.options.ns.push(n)}), this.loadResources(n=>{s.resolve(), e && e(n)}), s) : (e && e(), Promise.resolve())}loadLanguages(t, e) {const s = ne(); O(t) && (t = [t]); const n = this.options.preload || [], r = t.filter(o=>n.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o)); return r.length ? (this.options.preload = n.concat(r), this.loadResources(o=>{s.resolve(), e && e(o)}), s) : (e && e(), Promise.resolve())}dir(t) {if (t || (t = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language)), !t) return 'rtl'; try {const n = new Intl.Locale(t); if (n && n.getTextInfo) {const r = n.getTextInfo(); if (r && r.direction) return r.direction}} catch {} const e = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'], s = this.services?.languageUtils || new _i(Ti()); return t.toLowerCase().indexOf('-latn') > 1 ? 'ltr' : e.indexOf(s.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr'} static createInstance(t = {}, e) {return new fe(t, e)}cloneInstance(t = {}, e = Se) {const s = t.forkResourceStore; s && delete t.forkResourceStore; const n = { ...this.options, ...t, isClone:!0 }, r = new fe(n); if ((t.debug !== void 0 || t.prefix !== void 0) && (r.logger = r.logger.clone(t)), ['store', 'services', 'language'].forEach(a=>{r[a] = this[a]}), r.services = { ...this.services }, r.services.utils = { hasLoadedNamespace:r.hasLoadedNamespace.bind(r) }, s) {const a = Object.keys(this.store.data).reduce((l, c)=>(l[c] = { ...this.store.data[c] }, l[c] = Object.keys(l[c]).reduce((u, h)=>(u[h] = { ...l[c][h] }, u), l[c]), l), {}); r.store = new pi(a, n), r.services.resourceStore = r.store} return r.translator = new Ve(r.services, n), r.translator.on('*', (a, ...l)=>{r.emit(a, ...l)}), r.init(n, e), r.translator.options = n, r.translator.backendConnector.services.utils = { hasLoadedNamespace:r.hasLoadedNamespace.bind(r) }, r}toJSON() {return { options:this.options, store:this.store, language:this.language, languages:this.languages, resolvedLanguage:this.resolvedLanguage }}} const F = fe.createInstance(); F.createInstance = fe.createInstance; F.createInstance; F.dir; F.init; F.loadResources; F.reloadResources; F.use; F.changeLanguage; F.getFixedT; F.t; F.exists; F.setDefaultNamespace; F.hasLoadedNamespace; F.loadNamespaces; F.loadLanguages; const $o = { translation:{ app:{ title:'RSS агрегатор', description:'Начните читать RSS сегодня! Это легко, это красиво.', example:'Пример: https://lorem-rss.hexlet.app/feed', add:'Добавить' }, errors:{ invalidUrl:'Ссылка должна быть валидной', alreadyExists:'RSS уже существует', required:'Поле не должно быть пустым', network:'Ошибка сети', parseError:'Ресурс не содержит валидный RSS' }, success:'RSS успешно загружен' } }, zt = F.createInstance(); await zt.init({ lng:'ru', debug:!1, resources:{ ru:$o } }); var V = 'top', U = 'bottom', z = 'right', j = 'left', Ue = 'auto', Zt = [V, U, z, j], Dt = 'start', Yt = 'end', Tn = 'clippingParents', Ds = 'viewport', Ht = 'popper', wn = 'reference', Ss = Zt.reduce(function(i, t) {return i.concat([t + '-' + Dt, t + '-' + Yt])}, []), Is = [].concat(Zt, [Ue]).reduce(function(i, t) {return i.concat([t, t + '-' + Dt, t + '-' + Yt])}, []), Sn = 'beforeRead', On = 'read', An = 'afterRead', xn = 'beforeMain', Cn = 'main', $n = 'afterMain', Nn = 'beforeWrite', Ln = 'write', Dn = 'afterWrite', In = [Sn, On, An, xn, Cn, $n, Nn, Ln, Dn]; function at(i) {return i ? (i.nodeName || '').toLowerCase() : null} function Y(i) {if (i == null) return window; if (i.toString() !== '[object Window]') {var t = i.ownerDocument; return t && t.defaultView || window} return i} function It(i) {var t = Y(i).Element; return i instanceof t || i instanceof Element} function G(i) {var t = Y(i).HTMLElement; return i instanceof t || i instanceof HTMLElement} function Ps(i) {if (typeof ShadowRoot > 'u') return !1; var t = Y(i).ShadowRoot; return i instanceof t || i instanceof ShadowRoot} function No(i) {var t = i.state; Object.keys(t.elements).forEach(function(e) {var s = t.styles[e] || {}, n = t.attributes[e] || {}, r = t.elements[e]; !G(r) || !at(r) || (Object.assign(r.style, s), Object.keys(n).forEach(function(o) {var a = n[o]; a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? '' : a)}))})} function Lo(i) {var t = i.state, e = { popper:{ position:t.options.strategy, left:'0', top:'0', margin:'0' }, arrow:{ position:'absolute' }, reference:{} }; return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {Object.keys(t.elements).forEach(function(s) {var n = t.elements[s], r = t.attributes[s] || {}, o = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), a = o.reduce(function(l, c) {return l[c] = '', l}, {}); !G(n) || !at(n) || (Object.assign(n.style, a), Object.keys(r).forEach(function(l) {n.removeAttribute(l)}))})}} const Rs = { name:'applyStyles', enabled:!0, phase:'write', fn:No, effect:Lo, requires:['computeStyles'] }; function rt(i) {return i.split('-')[0]} var Lt = Math.max, je = Math.min, qt = Math.round; function Os() {var i = navigator.userAgentData; return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {return t.brand + '/' + t.version}).join(' ') : navigator.userAgent} function Pn() {return !/^((?!chrome|android).)*safari/i.test(Os())} function Gt(i, t, e) {t === void 0 && (t = !1), e === void 0 && (e = !1); var s = i.getBoundingClientRect(), n = 1, r = 1; t && G(i) && (n = i.offsetWidth > 0 && qt(s.width) / i.offsetWidth || 1, r = i.offsetHeight > 0 && qt(s.height) / i.offsetHeight || 1); var o = It(i) ? Y(i) : window, a = o.visualViewport, l = !Pn() && e, c = (s.left + (l && a ? a.offsetLeft : 0)) / n, u = (s.top + (l && a ? a.offsetTop : 0)) / r, h = s.width / n, p = s.height / r; return { width:h, height:p, top:u, right:c + h, bottom:u + p, left:c, x:c, y:u }} function ks(i) {var t = Gt(i), e = i.offsetWidth, s = i.offsetHeight; return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), { x:i.offsetLeft, y:i.offsetTop, width:e, height:s }} function Rn(i, t) {var e = t.getRootNode && t.getRootNode(); if (i.contains(t)) return !0; if (e && Ps(e)) {var s = t; do {if (s && i.isSameNode(s)) return !0; s = s.parentNode || s.host} while (s)} return !1} function ft(i) {return Y(i).getComputedStyle(i)} function Do(i) {return ['table', 'td', 'th'].indexOf(at(i)) >= 0} function Tt(i) {return ((It(i) ? i.ownerDocument : i.document) || window.document).documentElement} function ze(i) {return at(i) === 'html' ? i : i.assignedSlot || i.parentNode || (Ps(i) ? i.host : null) || Tt(i)} function Si(i) {return !G(i) || ft(i).position === 'fixed' ? null : i.offsetParent} function Io(i) {var t = /firefox/i.test(Os()), e = /Trident/i.test(Os()); if (e && G(i)) {var s = ft(i); if (s.position === 'fixed') return null} var n = ze(i); for (Ps(n) && (n = n.host); G(n) && ['html', 'body'].indexOf(at(n)) < 0;) {var r = ft(n); if (r.transform !== 'none' || r.perspective !== 'none' || r.contain === 'paint' || ['transform', 'perspective'].indexOf(r.willChange) !== -1 || t && r.willChange === 'filter' || t && r.filter && r.filter !== 'none') return n; n = n.parentNode} return null} function ge(i) {for (var t = Y(i), e = Si(i); e && Do(e) && ft(e).position === 'static';)e = Si(e); return e && (at(e) === 'html' || at(e) === 'body' && ft(e).position === 'static') ? t : e || Io(i) || t} function Fs(i) {return ['top', 'bottom'].indexOf(i) >= 0 ? 'x' : 'y'} function ce(i, t, e) {return Lt(i, je(t, e))} function Po(i, t, e) {var s = ce(i, t, e); return s > e ? e : s} function kn() {return { top:0, right:0, bottom:0, left:0 }} function Fn(i) {return Object.assign({}, kn(), i)} function Mn(i, t) {return t.reduce(function(e, s) {return e[s] = i, e}, {})} var Ro = function(t, e) {return t = typeof t == 'function' ? t(Object.assign({}, e.rects, { placement:e.placement })) : t, Fn(typeof t != 'number' ? t : Mn(t, Zt))}; function ko(i) {var t, e = i.state, s = i.name, n = i.options, r = e.elements.arrow, o = e.modifiersData.popperOffsets, a = rt(e.placement), l = Fs(a), c = [j, z].indexOf(a) >= 0, u = c ? 'height' : 'width'; if (!(!r || !o)) {var h = Ro(n.padding, e), p = ks(r), f = l === 'y' ? V : j, m = l === 'y' ? U : z, _ = e.rects.reference[u] + e.rects.reference[l] - o[l] - e.rects.popper[u], b = o[l] - e.rects.reference[l], g = ge(r), E = g ? l === 'y' ? g.clientHeight || 0 : g.clientWidth || 0 : 0, S = _ / 2 - b / 2, v = h[f], y = E - p[u] - h[m], T = E / 2 - p[u] / 2 + S, A = ce(v, T, y), N = l; e.modifiersData[s] = (t = {}, t[N] = A, t.centerOffset = A - T, t)}} function Fo(i) {var t = i.state, e = i.options, s = e.element, n = s === void 0 ? '[data-popper-arrow]' : s; n != null && (typeof n == 'string' && (n = t.elements.popper.querySelector(n), !n) || Rn(t.elements.popper, n) && (t.elements.arrow = n))} const Vn = { name:'arrow', enabled:!0, phase:'main', fn:ko, effect:Fo, requires:['popperOffsets'], requiresIfExists:['preventOverflow'] }; function Xt(i) {return i.split('-')[1]} var Mo = { top:'auto', right:'auto', bottom:'auto', left:'auto' }; function Vo(i, t) {var e = i.x, s = i.y, n = t.devicePixelRatio || 1; return { x:qt(e * n) / n || 0, y:qt(s * n) / n || 0 }} function Oi(i) {var t, e = i.popper, s = i.popperRect, n = i.placement, r = i.variation, o = i.offsets, a = i.position, l = i.gpuAcceleration, c = i.adaptive, u = i.roundOffsets, h = i.isFixed, p = o.x, f = p === void 0 ? 0 : p, m = o.y, _ = m === void 0 ? 0 : m, b = typeof u == 'function' ? u({ x:f, y:_ }) : { x:f, y:_ }; f = b.x, _ = b.y; var g = o.hasOwnProperty('x'), E = o.hasOwnProperty('y'), S = j, v = V, y = window; if (c) {var T = ge(e), A = 'clientHeight', N = 'clientWidth'; if (T === Y(e) && (T = Tt(e), ft(T).position !== 'static' && a === 'absolute' && (A = 'scrollHeight', N = 'scrollWidth')), T = T, n === V || (n === j || n === z) && r === Yt) {v = U; var x = h && T === y && y.visualViewport ? y.visualViewport.height : T[A]; _ -= x - s.height, _ *= l ? 1 : -1} if (n === j || (n === V || n === U) && r === Yt) {S = z; var $ = h && T === y && y.visualViewport ? y.visualViewport.width : T[N]; f -= $ - s.width, f *= l ? 1 : -1}} var C = Object.assign({ position:a }, c && Mo), R = u === !0 ? Vo({ x:f, y:_ }, Y(e)) : { x:f, y:_ }; if (f = R.x, _ = R.y, l) {var L; return Object.assign({}, C, (L = {}, L[v] = E ? '0' : '', L[S] = g ? '0' : '', L.transform = (y.devicePixelRatio || 1) <= 1 ? 'translate(' + f + 'px, ' + _ + 'px)' : 'translate3d(' + f + 'px, ' + _ + 'px, 0)', L))} return Object.assign({}, C, (t = {}, t[v] = E ? _ + 'px' : '', t[S] = g ? f + 'px' : '', t.transform = '', t))} function jo(i) {var t = i.state, e = i.options, s = e.gpuAcceleration, n = s === void 0 ? !0 : s, r = e.adaptive, o = r === void 0 ? !0 : r, a = e.roundOffsets, l = a === void 0 ? !0 : a, c = { placement:rt(t.placement), variation:Xt(t.placement), popper:t.elements.popper, popperRect:t.rects.popper, gpuAcceleration:n, isFixed:t.options.strategy === 'fixed' }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Oi(Object.assign({}, c, { offsets:t.modifiersData.popperOffsets, position:t.options.strategy, adaptive:o, roundOffsets:l })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Oi(Object.assign({}, c, { offsets:t.modifiersData.arrow, position:'absolute', adaptive:!1, roundOffsets:l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-placement':t.placement })} const Ms = { name:'computeStyles', enabled:!0, phase:'beforeWrite', fn:jo, data:{} }; var Oe = { passive:!0 }; function Ho(i) {var t = i.state, e = i.instance, s = i.options, n = s.scroll, r = n === void 0 ? !0 : n, o = s.resize, a = o === void 0 ? !0 : o, l = Y(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && c.forEach(function(u) {u.addEventListener('scroll', e.update, Oe)}), a && l.addEventListener('resize', e.update, Oe), function() {r && c.forEach(function(u) {u.removeEventListener('scroll', e.update, Oe)}), a && l.removeEventListener('resize', e.update, Oe)}} const Vs = { name:'eventListeners', enabled:!0, phase:'write', fn:function() {}, effect:Ho, data:{} }; var Ko = { left:'right', right:'left', bottom:'top', top:'bottom' }; function De(i) {return i.replace(/left|right|bottom|top/g, function(t) {return Ko[t]})} var Bo = { start:'end', end:'start' }; function Ai(i) {return i.replace(/start|end/g, function(t) {return Bo[t]})} function js(i) {var t = Y(i), e = t.pageXOffset, s = t.pageYOffset; return { scrollLeft:e, scrollTop:s }} function Hs(i) {return Gt(Tt(i)).left + js(i).scrollLeft} function Wo(i, t) {var e = Y(i), s = Tt(i), n = e.visualViewport, r = s.clientWidth, o = s.clientHeight, a = 0, l = 0; if (n) {r = n.width, o = n.height; var c = Pn(); (c || !c && t === 'fixed') && (a = n.offsetLeft, l = n.offsetTop)} return { width:r, height:o, x:a + Hs(i), y:l }} function Uo(i) {var t, e = Tt(i), s = js(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, r = Lt(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = Lt(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + Hs(i), l = -s.scrollTop; return ft(n || e).direction === 'rtl' && (a += Lt(e.clientWidth, n ? n.clientWidth : 0) - r), { width:r, height:o, x:a, y:l }} function Ks(i) {var t = ft(i), e = t.overflow, s = t.overflowX, n = t.overflowY; return /auto|scroll|overlay|hidden/.test(e + n + s)} function jn(i) {return ['html', 'body', '#document'].indexOf(at(i)) >= 0 ? i.ownerDocument.body : G(i) && Ks(i) ? i : jn(ze(i))} function ue(i, t) {var e; t === void 0 && (t = []); var s = jn(i), n = s === ((e = i.ownerDocument) == null ? void 0 : e.body), r = Y(s), o = n ? [r].concat(r.visualViewport || [], Ks(s) ? s : []) : s, a = t.concat(o); return n ? a : a.concat(ue(ze(o)))} function As(i) {return Object.assign({}, i, { left:i.x, top:i.y, right:i.x + i.width, bottom:i.y + i.height })} function zo(i, t) {var e = Gt(i, !1, t === 'fixed'); return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e} function xi(i, t, e) {return t === Ds ? As(Wo(i, e)) : It(t) ? zo(t, e) : As(Uo(Tt(i)))} function Yo(i) {var t = ue(ze(i)), e = ['absolute', 'fixed'].indexOf(ft(i).position) >= 0, s = e && G(i) ? ge(i) : i; return It(s) ? t.filter(function(n) {return It(n) && Rn(n, s) && at(n) !== 'body'}) : []} function qo(i, t, e, s) {var n = t === 'clippingParents' ? Yo(i) : [].concat(t), r = [].concat(n, [e]), o = r[0], a = r.reduce(function(l, c) {var u = xi(i, c, s); return l.top = Lt(u.top, l.top), l.right = je(u.right, l.right), l.bottom = je(u.bottom, l.bottom), l.left = Lt(u.left, l.left), l}, xi(i, o, s)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a} function Hn(i) {var t = i.reference, e = i.element, s = i.placement, n = s ? rt(s) : null, r = s ? Xt(s) : null, o = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l; switch (n) {case V:l = { x:o, y:t.y - e.height }; break; case U:l = { x:o, y:t.y + t.height }; break; case z:l = { x:t.x + t.width, y:a }; break; case j:l = { x:t.x - e.width, y:a }; break; default:l = { x:t.x, y:t.y }} var c = n ? Fs(n) : null; if (c != null) {var u = c === 'y' ? 'height' : 'width'; switch (r) {case Dt:l[c] = l[c] - (t[u] / 2 - e[u] / 2); break; case Yt:l[c] = l[c] + (t[u] / 2 - e[u] / 2); break}} return l} function Qt(i, t) {t === void 0 && (t = {}); var e = t, s = e.placement, n = s === void 0 ? i.placement : s, r = e.strategy, o = r === void 0 ? i.strategy : r, a = e.boundary, l = a === void 0 ? Tn : a, c = e.rootBoundary, u = c === void 0 ? Ds : c, h = e.elementContext, p = h === void 0 ? Ht : h, f = e.altBoundary, m = f === void 0 ? !1 : f, _ = e.padding, b = _ === void 0 ? 0 : _, g = Fn(typeof b != 'number' ? b : Mn(b, Zt)), E = p === Ht ? wn : Ht, S = i.rects.popper, v = i.elements[m ? E : p], y = qo(It(v) ? v : v.contextElement || Tt(i.elements.popper), l, u, o), T = Gt(i.elements.reference), A = Hn({ reference:T, element:S, placement:n }), N = As(Object.assign({}, S, A)), x = p === Ht ? N : T, $ = { top:y.top - x.top + g.top, bottom:x.bottom - y.bottom + g.bottom, left:y.left - x.left + g.left, right:x.right - y.right + g.right }, C = i.modifiersData.offset; if (p === Ht && C) {var R = C[n]; Object.keys($).forEach(function(L) {var P = [z, U].indexOf(L) >= 0 ? 1 : -1, tt = [V, U].indexOf(L) >= 0 ? 'y' : 'x'; $[L] += R[tt] * P})} return $} function Go(i, t) {t === void 0 && (t = {}); var e = t, s = e.placement, n = e.boundary, r = e.rootBoundary, o = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, c = l === void 0 ? Is : l, u = Xt(s), h = u ? a ? Ss : Ss.filter(function(m) {return Xt(m) === u}) : Zt, p = h.filter(function(m) {return c.indexOf(m) >= 0}); p.length === 0 && (p = h); var f = p.reduce(function(m, _) {return m[_] = Qt(i, { placement:_, boundary:n, rootBoundary:r, padding:o })[rt(_)], m}, {}); return Object.keys(f).sort(function(m, _) {return f[m] - f[_]})} function Xo(i) {if (rt(i) === Ue) return []; var t = De(i); return [Ai(i), t, Ai(t)]} function Qo(i) {var t = i.state, e = i.options, s = i.name; if (!t.modifiersData[s]._skip) {for (var n = e.mainAxis, r = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !0 : o, l = e.fallbackPlacements, c = e.padding, u = e.boundary, h = e.rootBoundary, p = e.altBoundary, f = e.flipVariations, m = f === void 0 ? !0 : f, _ = e.allowedAutoPlacements, b = t.options.placement, g = rt(b), E = g === b, S = l || (E || !m ? [De(b)] : Xo(b)), v = [b].concat(S).reduce(function(lt, pt) {return lt.concat(rt(pt) === Ue ? Go(t, { placement:pt, boundary:u, rootBoundary:h, padding:c, flipVariations:m, allowedAutoPlacements:_ }) : pt)}, []), y = t.rects.reference, T = t.rects.popper, A = new Map, N = !0, x = v[0], $ = 0; $ < v.length; $++) {var C = v[$], R = rt(C), L = Xt(C) === Dt, P = [V, U].indexOf(R) >= 0, tt = P ? 'width' : 'height', D = Qt(t, { placement:C, boundary:u, rootBoundary:h, altBoundary:p, padding:c }), I = P ? L ? z : j : L ? U : V; y[tt] > T[tt] && (I = De(I)); var et = De(I), q = []; if (r && q.push(D[R] <= 0), a && q.push(D[I] <= 0, D[et] <= 0), q.every(function(lt) {return lt})) {x = C, N = !1; break}A.set(C, q)} if (N) for (var Ot = m ? 3 : 1, k = function(pt) {var ie = v.find(function(be) {var At = A.get(be); if (At) return At.slice(0, pt).every(function(Ze) {return Ze})}); if (ie) return x = ie, 'break'}, B = Ot; B > 0; B--) {var st = k(B); if (st === 'break') break}t.placement !== x && (t.modifiersData[s]._skip = !0, t.placement = x, t.reset = !0)}} const Kn = { name:'flip', enabled:!0, phase:'main', fn:Qo, requiresIfExists:['offset'], data:{ _skip:!1 } }; function Ci(i, t, e) {return e === void 0 && (e = { x:0, y:0 }), { top:i.top - t.height - e.y, right:i.right - t.width + e.x, bottom:i.bottom - t.height + e.y, left:i.left - t.width - e.x }} function $i(i) {return [V, z, U, j].some(function(t) {return i[t] >= 0})} function Jo(i) {var t = i.state, e = i.name, s = t.rects.reference, n = t.rects.popper, r = t.modifiersData.preventOverflow, o = Qt(t, { elementContext:'reference' }), a = Qt(t, { altBoundary:!0 }), l = Ci(o, s), c = Ci(a, n, r), u = $i(l), h = $i(c); t.modifiersData[e] = { referenceClippingOffsets:l, popperEscapeOffsets:c, isReferenceHidden:u, hasPopperEscaped:h }, t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-reference-hidden':u, 'data-popper-escaped':h })} const Bn = { name:'hide', enabled:!0, phase:'main', requiresIfExists:['preventOverflow'], fn:Jo }; function Zo(i, t, e) {var s = rt(i), n = [j, V].indexOf(s) >= 0 ? -1 : 1, r = typeof e == 'function' ? e(Object.assign({}, t, { placement:i })) : e, o = r[0], a = r[1]; return o = o || 0, a = (a || 0) * n, [j, z].indexOf(s) >= 0 ? { x:a, y:o } : { x:o, y:a }} function ta(i) {var t = i.state, e = i.options, s = i.name, n = e.offset, r = n === void 0 ? [0, 0] : n, o = Is.reduce(function(u, h) {return u[h] = Zo(h, t.rects, r), u}, {}), a = o[t.placement], l = a.x, c = a.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[s] = o} const Wn = { name:'offset', enabled:!0, phase:'main', requires:['popperOffsets'], fn:ta }; function ea(i) {var t = i.state, e = i.name; t.modifiersData[e] = Hn({ reference:t.rects.reference, element:t.rects.popper, placement:t.placement })} const Bs = { name:'popperOffsets', enabled:!0, phase:'read', fn:ea, data:{} }; function sa(i) {return i === 'x' ? 'y' : 'x'} function ia(i) {var t = i.state, e = i.options, s = i.name, n = e.mainAxis, r = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !1 : o, l = e.boundary, c = e.rootBoundary, u = e.altBoundary, h = e.padding, p = e.tether, f = p === void 0 ? !0 : p, m = e.tetherOffset, _ = m === void 0 ? 0 : m, b = Qt(t, { boundary:l, rootBoundary:c, padding:h, altBoundary:u }), g = rt(t.placement), E = Xt(t.placement), S = !E, v = Fs(g), y = sa(v), T = t.modifiersData.popperOffsets, A = t.rects.reference, N = t.rects.popper, x = typeof _ == 'function' ? _(Object.assign({}, t.rects, { placement:t.placement })) : _, $ = typeof x == 'number' ? { mainAxis:x, altAxis:x } : Object.assign({ mainAxis:0, altAxis:0 }, x), C = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, R = { x:0, y:0 }; if (T) {if (r) {var L, P = v === 'y' ? V : j, tt = v === 'y' ? U : z, D = v === 'y' ? 'height' : 'width', I = T[v], et = I + b[P], q = I - b[tt], Ot = f ? -N[D] / 2 : 0, k = E === Dt ? A[D] : N[D], B = E === Dt ? -N[D] : -A[D], st = t.elements.arrow, lt = f && st ? ks(st) : { width:0, height:0 }, pt = t.modifiersData['arrow#persistent'] ? t.modifiersData['arrow#persistent'].padding : kn(), ie = pt[P], be = pt[tt], At = ce(0, A[D], lt[D]), Ze = S ? A[D] / 2 - Ot - At - ie - $.mainAxis : k - At - ie - $.mainAxis, Sr = S ? -A[D] / 2 + Ot + At + be + $.mainAxis : B + At + be + $.mainAxis, ts = t.elements.arrow && ge(t.elements.arrow), Or = ts ? v === 'y' ? ts.clientTop || 0 : ts.clientLeft || 0 : 0, Qs = (L = C?.[v]) != null ? L : 0, Ar = I + Ze - Qs - Or, xr = I + Sr - Qs, Js = ce(f ? je(et, Ar) : et, I, f ? Lt(q, xr) : q); T[v] = Js, R[v] = Js - I} if (a) {var Zs, Cr = v === 'x' ? V : j, $r = v === 'x' ? U : z, xt = T[y], ye = y === 'y' ? 'height' : 'width', ti = xt + b[Cr], ei = xt - b[$r], es = [V, j].indexOf(g) !== -1, si = (Zs = C?.[y]) != null ? Zs : 0, ii = es ? ti : xt - A[ye] - N[ye] - si + $.altAxis, ni = es ? xt + A[ye] + N[ye] - si - $.altAxis : ei, ri = f && es ? Po(ii, xt, ni) : ce(f ? ii : ti, xt, f ? ni : ei); T[y] = ri, R[y] = ri - xt}t.modifiersData[s] = R}} const Un = { name:'preventOverflow', enabled:!0, phase:'main', fn:ia, requiresIfExists:['offset'] }; function na(i) {return { scrollLeft:i.scrollLeft, scrollTop:i.scrollTop }} function ra(i) {return i === Y(i) || !G(i) ? js(i) : na(i)} function oa(i) {var t = i.getBoundingClientRect(), e = qt(t.width) / i.offsetWidth || 1, s = qt(t.height) / i.offsetHeight || 1; return e !== 1 || s !== 1} function aa(i, t, e) {e === void 0 && (e = !1); var s = G(t), n = G(t) && oa(t), r = Tt(t), o = Gt(i, n, e), a = { scrollLeft:0, scrollTop:0 }, l = { x:0, y:0 }; return (s || !s && !e) && ((at(t) !== 'body' || Ks(r)) && (a = ra(t)), G(t) ? (l = Gt(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : r && (l.x = Hs(r))), { x:o.left + a.scrollLeft - l.x, y:o.top + a.scrollTop - l.y, width:o.width, height:o.height }} function la(i) {var t = new Map, e = new Set, s = []; i.forEach(function(r) {t.set(r.name, r)}); function n(r) {e.add(r.name); var o = [].concat(r.requires || [], r.requiresIfExists || []); o.forEach(function(a) {if (!e.has(a)) {var l = t.get(a); l && n(l)}}), s.push(r)} return i.forEach(function(r) {e.has(r.name) || n(r)}), s} function ca(i) {var t = la(i); return In.reduce(function(e, s) {return e.concat(t.filter(function(n) {return n.phase === s}))}, [])} function ua(i) {var t; return function() {return t || (t = new Promise(function(e) {Promise.resolve().then(function() {t = void 0, e(i())})})), t}} function ha(i) {var t = i.reduce(function(e, s) {var n = e[s.name]; return e[s.name] = n ? Object.assign({}, n, s, { options:Object.assign({}, n.options, s.options), data:Object.assign({}, n.data, s.data) }) : s, e}, {}); return Object.keys(t).map(function(e) {return t[e]})} var Ni = { placement:'bottom', modifiers:[], strategy:'absolute' }; function Li() {for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)t[e] = arguments[e]; return !t.some(function(s) {return !(s && typeof s.getBoundingClientRect == 'function')})} function Ye(i) {i === void 0 && (i = {}); var t = i, e = t.defaultModifiers, s = e === void 0 ? [] : e, n = t.defaultOptions, r = n === void 0 ? Ni : n; return function(a, l, c) {c === void 0 && (c = r); var u = { placement:'bottom', orderedModifiers:[], options:Object.assign({}, Ni, r), modifiersData:{}, elements:{ reference:a, popper:l }, attributes:{}, styles:{} }, h = [], p = !1, f = { state:u, setOptions:function(g) {var E = typeof g == 'function' ? g(u.options) : g; _(), u.options = Object.assign({}, r, u.options, E), u.scrollParents = { reference:It(a) ? ue(a) : a.contextElement ? ue(a.contextElement) : [], popper:ue(l) }; var S = ca(ha([].concat(s, u.options.modifiers))); return u.orderedModifiers = S.filter(function(v) {return v.enabled}), m(), f.update()}, forceUpdate:function() {if (!p) {var g = u.elements, E = g.reference, S = g.popper; if (Li(E, S)) {u.rects = { reference:aa(E, ge(S), u.options.strategy === 'fixed'), popper:ks(S) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function($) {return u.modifiersData[$.name] = Object.assign({}, $.data)}); for (var v = 0; v < u.orderedModifiers.length; v++) {if (u.reset === !0) {u.reset = !1, v = -1; continue} var y = u.orderedModifiers[v], T = y.fn, A = y.options, N = A === void 0 ? {} : A, x = y.name; typeof T == 'function' && (u = T({ state:u, options:N, name:x, instance:f }) || u)}}}}, update:ua(function() {return new Promise(function(b) {f.forceUpdate(), b(u)})}), destroy:function() {_(), p = !0} }; if (!Li(a, l)) return f; f.setOptions(c).then(function(b) {!p && c.onFirstUpdate && c.onFirstUpdate(b)}); function m() {u.orderedModifiers.forEach(function(b) {var g = b.name, E = b.options, S = E === void 0 ? {} : E, v = b.effect; if (typeof v == 'function') {var y = v({ state:u, name:g, instance:f, options:S }), T = function() {}; h.push(y || T)}})} function _() {h.forEach(function(b) {return b()}), h = []} return f}} var fa = Ye(), da = [Vs, Bs, Ms, Rs], pa = Ye({ defaultModifiers:da }), ga = [Vs, Bs, Ms, Rs, Wn, Kn, Un, Vn, Bn], Ws = Ye({ defaultModifiers:ga }); const zn = Object.freeze(Object.defineProperty({ __proto__:null, afterMain:$n, afterRead:An, afterWrite:Dn, applyStyles:Rs, arrow:Vn, auto:Ue, basePlacements:Zt, beforeMain:xn, beforeRead:Sn, beforeWrite:Nn, bottom:U, clippingParents:Tn, computeStyles:Ms, createPopper:Ws, createPopperBase:fa, createPopperLite:pa, detectOverflow:Qt, end:Yt, eventListeners:Vs, flip:Kn, hide:Bn, left:j, main:Cn, modifierPhases:In, offset:Wn, placements:Is, popper:Ht, popperGenerator:Ye, popperOffsets:Bs, preventOverflow:Un, read:On, reference:wn, right:z, start:Dt, top:V, variationPlacements:Ss, viewport:Ds, write:Ln }, Symbol.toStringTag, { value:'Module' }))/*!
  * Bootstrap v5.3.8 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */const gt = new Map, ns = { set(i, t, e) {gt.has(i) || gt.set(i, new Map); const s = gt.get(i); if (!s.has(t) && s.size !== 0) {console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`); return}s.set(t, e)}, get(i, t) {return gt.has(i) && gt.get(i).get(t) || null}, remove(i, t) {if (!gt.has(i)) return; const e = gt.get(i); e.delete(t), e.size === 0 && gt.delete(i)} }, ma = 1e6, _a = 1e3, xs = 'transitionend', Yn = i=>(i && window.CSS && window.CSS.escape && (i = i.replace(/#([^\s"#']+)/g, (t, e)=>`#${CSS.escape(e)}`)), i), Ea = i=>i == null ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(), va = i=>{do i += Math.floor(Math.random() * ma); while (document.getElementById(i)); return i}, ba = i=>{if (!i) return 0; let { transitionDuration:t, transitionDelay:e } = window.getComputedStyle(i); const s = Number.parseFloat(t), n = Number.parseFloat(e); return !s && !n ? 0 : (t = t.split(',')[0], e = e.split(',')[0], (Number.parseFloat(t) + Number.parseFloat(e)) * _a)}, qn = i=>{i.dispatchEvent(new Event(xs))}, ut = i=>!i || typeof i != 'object' ? !1 : (typeof i.jquery < 'u' && (i = i[0]), typeof i.nodeType < 'u'), vt = i=>ut(i) ? i.jquery ? i[0] : i : typeof i == 'string' && i.length > 0 ? document.querySelector(Yn(i)) : null, te = i=>{if (!ut(i) || i.getClientRects().length === 0) return !1; const t = getComputedStyle(i).getPropertyValue('visibility') === 'visible', e = i.closest('details:not([open])'); if (!e) return t; if (e !== i) {const s = i.closest('summary'); if (s && s.parentNode !== e || s === null) return !1} return t}, bt = i=>!i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains('disabled') ? !0 : typeof i.disabled < 'u' ? i.disabled : i.hasAttribute('disabled') && i.getAttribute('disabled') !== 'false', Gn = i=>{if (!document.documentElement.attachShadow) return null; if (typeof i.getRootNode == 'function') {const t = i.getRootNode(); return t instanceof ShadowRoot ? t : null} return i instanceof ShadowRoot ? i : i.parentNode ? Gn(i.parentNode) : null}, He = ()=>{}, me = i=>{i.offsetHeight}, Xn = ()=>window.jQuery && !document.body.hasAttribute('data-bs-no-jquery') ? window.jQuery : null, rs = [], ya = i=>{document.readyState === 'loading' ? (rs.length || document.addEventListener('DOMContentLoaded', ()=>{for (const t of rs)t()}), rs.push(i)) : i()}, X = ()=>document.documentElement.dir === 'rtl', J = i=>{ya(()=>{const t = Xn(); if (t) {const e = i.NAME, s = t.fn[e]; t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = ()=>(t.fn[e] = s, i.jQueryInterface)}})}, K = (i, t = [], e = i)=>typeof i == 'function' ? i.call(...t) : e, Qn = (i, t, e = !0)=>{if (!e) {K(i); return} const n = ba(t) + 5; let r = !1; const o = ({ target:a })=>{a === t && (r = !0, t.removeEventListener(xs, o), K(i))}; t.addEventListener(xs, o), setTimeout(()=>{r || qn(t)}, n)}, Us = (i, t, e, s)=>{const n = i.length; let r = i.indexOf(t); return r === -1 ? !e && s ? i[n - 1] : i[0] : (r += e ? 1 : -1, s && (r = (r + n) % n), i[Math.max(0, Math.min(r, n - 1))])}, Ta = /[^.]*(?=\..*)\.|.*/, wa = /\..*/, Sa = /::\d+$/, os = {}; let Di = 1; const Jn = { mouseenter:'mouseover', mouseleave:'mouseout' }, Oa = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function Zn(i, t) {return t && `${t}::${Di++}` || i.uidEvent || Di++} function tr(i) {const t = Zn(i); return i.uidEvent = t, os[t] = os[t] || {}, os[t]} function Aa(i, t) {return function e(s) {return zs(s, { delegateTarget:i }), e.oneOff && d.off(i, s.type, t), t.apply(i, [s])}} function xa(i, t, e) {return function s(n) {const r = i.querySelectorAll(t); for (let { target:o } = n; o && o !== this; o = o.parentNode) for (const a of r) if (a === o) return zs(n, { delegateTarget:o }), s.oneOff && d.off(i, n.type, t, e), e.apply(o, [n])}} function er(i, t, e = null) {return Object.values(i).find(s=>s.callable === t && s.delegationSelector === e)} function sr(i, t, e) {const s = typeof t == 'string', n = s ? e : t || e; let r = ir(i); return Oa.has(r) || (r = i), [s, n, r]} function Ii(i, t, e, s, n) {if (typeof t != 'string' || !i) return; let [r, o, a] = sr(t, e, s); t in Jn && (o = (m=>function(_) {if (!_.relatedTarget || _.relatedTarget !== _.delegateTarget && !_.delegateTarget.contains(_.relatedTarget)) return m.call(this, _)})(o)); const l = tr(i), c = l[a] || (l[a] = {}), u = er(c, o, r ? e : null); if (u) {u.oneOff = u.oneOff && n; return} const h = Zn(o, t.replace(Ta, '')), p = r ? xa(i, e, o) : Aa(i, o); p.delegationSelector = r ? e : null, p.callable = o, p.oneOff = n, p.uidEvent = h, c[h] = p, i.addEventListener(a, p, r)} function Cs(i, t, e, s, n) {const r = er(t[e], s, n); r && (i.removeEventListener(e, r, !!n), delete t[e][r.uidEvent])} function Ca(i, t, e, s) {const n = t[e] || {}; for (const [r, o] of Object.entries(n))r.includes(s) && Cs(i, t, e, o.callable, o.delegationSelector)} function ir(i) {return i = i.replace(wa, ''), Jn[i] || i} const d = { on(i, t, e, s) {Ii(i, t, e, s, !1)}, one(i, t, e, s) {Ii(i, t, e, s, !0)}, off(i, t, e, s) {if (typeof t != 'string' || !i) return; const [n, r, o] = sr(t, e, s), a = o !== t, l = tr(i), c = l[o] || {}, u = t.startsWith('.'); if (typeof r < 'u') {if (!Object.keys(c).length) return; Cs(i, l, o, r, n ? e : null); return} if (u) for (const h of Object.keys(l))Ca(i, l, h, t.slice(1)); for (const [h, p] of Object.entries(c)) {const f = h.replace(Sa, ''); (!a || t.includes(f)) && Cs(i, l, o, p.callable, p.delegationSelector)}}, trigger(i, t, e) {if (typeof t != 'string' || !i) return null; const s = Xn(), n = ir(t), r = t !== n; let o = null, a = !0, l = !0, c = !1; r && s && (o = s.Event(t, e), s(i).trigger(o), a = !o.isPropagationStopped(), l = !o.isImmediatePropagationStopped(), c = o.isDefaultPrevented()); const u = zs(new Event(t, { bubbles:a, cancelable:!0 }), e); return c && u.preventDefault(), l && i.dispatchEvent(u), u.defaultPrevented && o && o.preventDefault(), u} }; function zs(i, t = {}) {for (const [e, s] of Object.entries(t)) try {i[e] = s} catch {Object.defineProperty(i, e, { configurable:!0, get() {return s} })} return i} function Pi(i) {if (i === 'true') return !0; if (i === 'false') return !1; if (i === Number(i).toString()) return Number(i); if (i === '' || i === 'null') return null; if (typeof i != 'string') return i; try {return JSON.parse(decodeURIComponent(i))} catch {return i}} function as(i) {return i.replace(/[A-Z]/g, t=>`-${t.toLowerCase()}`)} const ht = { setDataAttribute(i, t, e) {i.setAttribute(`data-bs-${as(t)}`, e)}, removeDataAttribute(i, t) {i.removeAttribute(`data-bs-${as(t)}`)}, getDataAttributes(i) {if (!i) return {}; const t = {}, e = Object.keys(i.dataset).filter(s=>s.startsWith('bs') && !s.startsWith('bsConfig')); for (const s of e) {let n = s.replace(/^bs/, ''); n = n.charAt(0).toLowerCase() + n.slice(1), t[n] = Pi(i.dataset[s])} return t}, getDataAttribute(i, t) {return Pi(i.getAttribute(`data-bs-${as(t)}`))} }; class _e {static get Default() {return {}} static get DefaultType() {return {}} static get NAME() {throw new Error('You have to implement the static method "NAME", for each component!')}_getConfig(t) {return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t}_configAfterMerge(t) {return t}_mergeConfigObj(t, e) {const s = ut(e) ? ht.getDataAttribute(e, 'config') : {}; return { ...this.constructor.Default, ...typeof s == 'object' ? s : {}, ...ut(e) ? ht.getDataAttributes(e) : {}, ...typeof t == 'object' ? t : {} }}_typeCheckConfig(t, e = this.constructor.DefaultType) {for (const [s, n] of Object.entries(e)) {const r = t[s], o = ut(r) ? 'element' : Ea(r); if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`)}}} const $a = '5.3.8'; class Z extends _e {constructor(t, e) {super(), t = vt(t), t && (this._element = t, this._config = this._getConfig(e), ns.set(this._element, this.constructor.DATA_KEY, this))}dispose() {ns.remove(this._element, this.constructor.DATA_KEY), d.off(this._element, this.constructor.EVENT_KEY); for (const t of Object.getOwnPropertyNames(this)) this[t] = null}_queueCallback(t, e, s = !0) {Qn(t, e, s)}_getConfig(t) {return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t} static getInstance(t) {return ns.get(vt(t), this.DATA_KEY)} static getOrCreateInstance(t, e = {}) {return this.getInstance(t) || new this(t, typeof e == 'object' ? e : null)} static get VERSION() {return $a} static get DATA_KEY() {return `bs.${this.NAME}`} static get EVENT_KEY() {return `.${this.DATA_KEY}`} static eventName(t) {return `${t}${this.EVENT_KEY}`}} const ls = i=>{let t = i.getAttribute('data-bs-target'); if (!t || t === '#') {let e = i.getAttribute('href'); if (!e || !e.includes('#') && !e.startsWith('.')) return null; e.includes('#') && !e.startsWith('#') && (e = `#${e.split('#')[1]}`), t = e && e !== '#' ? e.trim() : null} return t ? t.split(',').map(e=>Yn(e)).join(',') : null}, w = { find(i, t = document.documentElement) {return [].concat(...Element.prototype.querySelectorAll.call(t, i))}, findOne(i, t = document.documentElement) {return Element.prototype.querySelector.call(t, i)}, children(i, t) {return [].concat(...i.children).filter(e=>e.matches(t))}, parents(i, t) {const e = []; let s = i.parentNode.closest(t); for (;s;)e.push(s), s = s.parentNode.closest(t); return e}, prev(i, t) {let e = i.previousElementSibling; for (;e;) {if (e.matches(t)) return [e]; e = e.previousElementSibling} return []}, next(i, t) {let e = i.nextElementSibling; for (;e;) {if (e.matches(t)) return [e]; e = e.nextElementSibling} return []}, focusableChildren(i) {const t = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(e=>`${e}:not([tabindex^="-"])`).join(','); return this.find(t, i).filter(e=>!bt(e) && te(e))}, getSelectorFromElement(i) {const t = ls(i); return t && w.findOne(t) ? t : null}, getElementFromSelector(i) {const t = ls(i); return t ? w.findOne(t) : null}, getMultipleElementsFromSelector(i) {const t = ls(i); return t ? w.find(t) : []} }, qe = (i, t = 'hide')=>{const e = `click.dismiss${i.EVENT_KEY}`, s = i.NAME; d.on(document, e, `[data-bs-dismiss="${s}"]`, function(n) {if (['A', 'AREA'].includes(this.tagName) && n.preventDefault(), bt(this)) return; const r = w.getElementFromSelector(this) || this.closest(`.${s}`); i.getOrCreateInstance(r)[t]()})}, Na = 'alert', La = 'bs.alert', nr = `.${La}`, Da = `close${nr}`, Ia = `closed${nr}`, Pa = 'fade', Ra = 'show'; class Ge extends Z {static get NAME() {return Na}close() {if (d.trigger(this._element, Da).defaultPrevented) return; this._element.classList.remove(Ra); const e = this._element.classList.contains(Pa); this._queueCallback(()=>this._destroyElement(), this._element, e)}_destroyElement() {this._element.remove(), d.trigger(this._element, Ia), this.dispose()} static jQueryInterface(t) {return this.each(function() {const e = Ge.getOrCreateInstance(this); if (typeof t == 'string') {if (e[t] === void 0 || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](this)}})}}qe(Ge, 'close'); J(Ge); const ka = 'button', Fa = 'bs.button', Ma = `.${Fa}`, Va = '.data-api', ja = 'active', Ri = '[data-bs-toggle="button"]', Ha = `click${Ma}${Va}`; class Xe extends Z {static get NAME() {return ka}toggle() {this._element.setAttribute('aria-pressed', this._element.classList.toggle(ja))} static jQueryInterface(t) {return this.each(function() {const e = Xe.getOrCreateInstance(this); t === 'toggle' && e[t]()})}}d.on(document, Ha, Ri, i=>{i.preventDefault(); const t = i.target.closest(Ri); Xe.getOrCreateInstance(t).toggle()}); J(Xe); const Ka = 'swipe', ee = '.bs.swipe', Ba = `touchstart${ee}`, Wa = `touchmove${ee}`, Ua = `touchend${ee}`, za = `pointerdown${ee}`, Ya = `pointerup${ee}`, qa = 'touch', Ga = 'pen', Xa = 'pointer-event', Qa = 40, Ja = { endCallback:null, leftCallback:null, rightCallback:null }, Za = { endCallback:'(function|null)', leftCallback:'(function|null)', rightCallback:'(function|null)' }; class Ke extends _e {constructor(t, e) {super(), this._element = t, !(!t || !Ke.isSupported()) && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents())} static get Default() {return Ja} static get DefaultType() {return Za} static get NAME() {return Ka}dispose() {d.off(this._element, ee)}_start(t) {if (!this._supportPointerEvents) {this._deltaX = t.touches[0].clientX; return} this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)}_end(t) {this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), K(this._config.endCallback)}_move(t) {this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX}_handleSwipe() {const t = Math.abs(this._deltaX); if (t <= Qa) return; const e = t / this._deltaX; this._deltaX = 0, e && K(e > 0 ? this._config.rightCallback : this._config.leftCallback)}_initEvents() {this._supportPointerEvents ? (d.on(this._element, za, t=>this._start(t)), d.on(this._element, Ya, t=>this._end(t)), this._element.classList.add(Xa)) : (d.on(this._element, Ba, t=>this._start(t)), d.on(this._element, Wa, t=>this._move(t)), d.on(this._element, Ua, t=>this._end(t)))}_eventIsPointerPenTouch(t) {return this._supportPointerEvents && (t.pointerType === Ga || t.pointerType === qa)} static isSupported() {return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0}} const tl = 'carousel', el = 'bs.carousel', wt = `.${el}`, rr = '.data-api', sl = 'ArrowLeft', il = 'ArrowRight', nl = 500, re = 'next', Vt = 'prev', Kt = 'left', Ie = 'right', rl = `slide${wt}`, cs = `slid${wt}`, ol = `keydown${wt}`, al = `mouseenter${wt}`, ll = `mouseleave${wt}`, cl = `dragstart${wt}`, ul = `load${wt}${rr}`, hl = `click${wt}${rr}`, or = 'carousel', Ae = 'active', fl = 'slide', dl = 'carousel-item-end', pl = 'carousel-item-start', gl = 'carousel-item-next', ml = 'carousel-item-prev', ar = '.active', lr = '.carousel-item', _l = ar + lr, El = '.carousel-item img', vl = '.carousel-indicators', bl = '[data-bs-slide], [data-bs-slide-to]', yl = '[data-bs-ride="carousel"]', Tl = { [sl]:Ie, [il]:Kt }, wl = { interval:5e3, keyboard:!0, pause:'hover', ride:!1, touch:!0, wrap:!0 }, Sl = { interval:'(number|boolean)', keyboard:'boolean', pause:'(string|boolean)', ride:'(boolean|string)', touch:'boolean', wrap:'boolean' }; class Ee extends Z {constructor(t, e) {super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = w.findOne(vl, this._element), this._addEventListeners(), this._config.ride === or && this.cycle()} static get Default() {return wl} static get DefaultType() {return Sl} static get NAME() {return tl}next() {this._slide(re)}nextWhenVisible() {!document.hidden && te(this._element) && this.next()}prev() {this._slide(Vt)}pause() {this._isSliding && qn(this._element), this._clearInterval()}cycle() {this._clearInterval(), this._updateInterval(), this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval)}_maybeEnableCycle() {if (this._config.ride) {if (this._isSliding) {d.one(this._element, cs, ()=>this.cycle()); return} this.cycle()}}to(t) {const e = this._getItems(); if (t > e.length - 1 || t < 0) return; if (this._isSliding) {d.one(this._element, cs, ()=>this.to(t)); return} const s = this._getItemIndex(this._getActive()); if (s === t) return; const n = t > s ? re : Vt; this._slide(n, e[t])}dispose() {this._swipeHelper && this._swipeHelper.dispose(), super.dispose()}_configAfterMerge(t) {return t.defaultInterval = t.interval, t}_addEventListeners() {this._config.keyboard && d.on(this._element, ol, t=>this._keydown(t)), this._config.pause === 'hover' && (d.on(this._element, al, ()=>this.pause()), d.on(this._element, ll, ()=>this._maybeEnableCycle())), this._config.touch && Ke.isSupported() && this._addTouchEventListeners()}_addTouchEventListeners() {for (const s of w.find(El, this._element))d.on(s, cl, n=>n.preventDefault()); const e = { leftCallback:()=>this._slide(this._directionToOrder(Kt)), rightCallback:()=>this._slide(this._directionToOrder(Ie)), endCallback:()=>{this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), nl + this._config.interval))} }; this._swipeHelper = new Ke(this._element, e)}_keydown(t) {if (/input|textarea/i.test(t.target.tagName)) return; const e = Tl[t.key]; e && (t.preventDefault(), this._slide(this._directionToOrder(e)))}_getItemIndex(t) {return this._getItems().indexOf(t)}_setActiveIndicatorElement(t) {if (!this._indicatorsElement) return; const e = w.findOne(ar, this._indicatorsElement); e.classList.remove(Ae), e.removeAttribute('aria-current'); const s = w.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement); s && (s.classList.add(Ae), s.setAttribute('aria-current', 'true'))}_updateInterval() {const t = this._activeElement || this._getActive(); if (!t) return; const e = Number.parseInt(t.getAttribute('data-bs-interval'), 10); this._config.interval = e || this._config.defaultInterval}_slide(t, e = null) {if (this._isSliding) return; const s = this._getActive(), n = t === re, r = e || Us(this._getItems(), s, n, this._config.wrap); if (r === s) return; const o = this._getItemIndex(r), a = f=>d.trigger(this._element, f, { relatedTarget:r, direction:this._orderToDirection(t), from:this._getItemIndex(s), to:o }); if (a(rl).defaultPrevented || !s || !r) return; const c = !!this._interval; this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = r; const u = n ? pl : dl, h = n ? gl : ml; r.classList.add(h), me(r), s.classList.add(u), r.classList.add(u); const p = ()=>{r.classList.remove(u, h), r.classList.add(Ae), s.classList.remove(Ae, h, u), this._isSliding = !1, a(cs)}; this._queueCallback(p, s, this._isAnimated()), c && this.cycle()}_isAnimated() {return this._element.classList.contains(fl)}_getActive() {return w.findOne(_l, this._element)}_getItems() {return w.find(lr, this._element)}_clearInterval() {this._interval && (clearInterval(this._interval), this._interval = null)}_directionToOrder(t) {return X() ? t === Kt ? Vt : re : t === Kt ? re : Vt}_orderToDirection(t) {return X() ? t === Vt ? Kt : Ie : t === Vt ? Ie : Kt} static jQueryInterface(t) {return this.each(function() {const e = Ee.getOrCreateInstance(this, t); if (typeof t == 'number') {e.to(t); return} if (typeof t == 'string') {if (e[t] === void 0 || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t]()}})}}d.on(document, hl, bl, function(i) {const t = w.getElementFromSelector(this); if (!t || !t.classList.contains(or)) return; i.preventDefault(); const e = Ee.getOrCreateInstance(t), s = this.getAttribute('data-bs-slide-to'); if (s) {e.to(s), e._maybeEnableCycle(); return} if (ht.getDataAttribute(this, 'slide') === 'next') {e.next(), e._maybeEnableCycle(); return}e.prev(), e._maybeEnableCycle()}); d.on(window, ul, ()=>{const i = w.find(yl); for (const t of i)Ee.getOrCreateInstance(t)}); J(Ee); const Ol = 'collapse', Al = 'bs.collapse', ve = `.${Al}`, xl = '.data-api', Cl = `show${ve}`, $l = `shown${ve}`, Nl = `hide${ve}`, Ll = `hidden${ve}`, Dl = `click${ve}${xl}`, us = 'show', Ut = 'collapse', xe = 'collapsing', Il = 'collapsed', Pl = `:scope .${Ut} .${Ut}`, Rl = 'collapse-horizontal', kl = 'width', Fl = 'height', Ml = '.collapse.show, .collapse.collapsing', $s = '[data-bs-toggle="collapse"]', Vl = { parent:null, toggle:!0 }, jl = { parent:'(null|element)', toggle:'boolean' }; class de extends Z {constructor(t, e) {super(t, e), this._isTransitioning = !1, this._triggerArray = []; const s = w.find($s); for (const n of s) {const r = w.getSelectorFromElement(n), o = w.find(r).filter(a=>a === this._element); r !== null && o.length && this._triggerArray.push(n)} this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()} static get Default() {return Vl} static get DefaultType() {return jl} static get NAME() {return Ol}toggle() {this._isShown() ? this.hide() : this.show()}show() {if (this._isTransitioning || this._isShown()) return; let t = []; if (this._config.parent && (t = this._getFirstLevelChildren(Ml).filter(a=>a !== this._element).map(a=>de.getOrCreateInstance(a, { toggle:!1 }))), t.length && t[0]._isTransitioning || d.trigger(this._element, Cl).defaultPrevented) return; for (const a of t)a.hide(); const s = this._getDimension(); this._element.classList.remove(Ut), this._element.classList.add(xe), this._element.style[s] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const n = ()=>{this._isTransitioning = !1, this._element.classList.remove(xe), this._element.classList.add(Ut, us), this._element.style[s] = '', d.trigger(this._element, $l)}, o = `scroll${s[0].toUpperCase() + s.slice(1)}`; this._queueCallback(n, this._element, !0), this._element.style[s] = `${this._element[o]}px`}hide() {if (this._isTransitioning || !this._isShown() || d.trigger(this._element, Nl).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, me(this._element), this._element.classList.add(xe), this._element.classList.remove(Ut, us); for (const n of this._triggerArray) {const r = w.getElementFromSelector(n); r && !this._isShown(r) && this._addAriaAndCollapsedClass([n], !1)} this._isTransitioning = !0; const s = ()=>{this._isTransitioning = !1, this._element.classList.remove(xe), this._element.classList.add(Ut), d.trigger(this._element, Ll)}; this._element.style[e] = '', this._queueCallback(s, this._element, !0)}_isShown(t = this._element) {return t.classList.contains(us)}_configAfterMerge(t) {return t.toggle = !!t.toggle, t.parent = vt(t.parent), t}_getDimension() {return this._element.classList.contains(Rl) ? kl : Fl}_initializeChildren() {if (!this._config.parent) return; const t = this._getFirstLevelChildren($s); for (const e of t) {const s = w.getElementFromSelector(e); s && this._addAriaAndCollapsedClass([e], this._isShown(s))}}_getFirstLevelChildren(t) {const e = w.find(Pl, this._config.parent); return w.find(t, this._config.parent).filter(s=>!e.includes(s))}_addAriaAndCollapsedClass(t, e) {if (t.length) for (const s of t)s.classList.toggle(Il, !e), s.setAttribute('aria-expanded', e)} static jQueryInterface(t) {const e = {}; return typeof t == 'string' && /show|hide/.test(t) && (e.toggle = !1), this.each(function() {const s = de.getOrCreateInstance(this, e); if (typeof t == 'string') {if (typeof s[t] > 'u') throw new TypeError(`No method named "${t}"`); s[t]()}})}}d.on(document, Dl, $s, function(i) {(i.target.tagName === 'A' || i.delegateTarget && i.delegateTarget.tagName === 'A') && i.preventDefault(); for (const t of w.getMultipleElementsFromSelector(this))de.getOrCreateInstance(t, { toggle:!1 }).toggle()}); J(de); const ki = 'dropdown', Hl = 'bs.dropdown', Rt = `.${Hl}`, Ys = '.data-api', Kl = 'Escape', Fi = 'Tab', Bl = 'ArrowUp', Mi = 'ArrowDown', Wl = 2, Ul = `hide${Rt}`, zl = `hidden${Rt}`, Yl = `show${Rt}`, ql = `shown${Rt}`, cr = `click${Rt}${Ys}`, ur = `keydown${Rt}${Ys}`, Gl = `keyup${Rt}${Ys}`, Bt = 'show', Xl = 'dropup', Ql = 'dropend', Jl = 'dropstart', Zl = 'dropup-center', tc = 'dropdown-center', $t = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', ec = `${$t}.${Bt}`, Pe = '.dropdown-menu', sc = '.navbar', ic = '.navbar-nav', nc = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)', rc = X() ? 'top-end' : 'top-start', oc = X() ? 'top-start' : 'top-end', ac = X() ? 'bottom-end' : 'bottom-start', lc = X() ? 'bottom-start' : 'bottom-end', cc = X() ? 'left-start' : 'right-start', uc = X() ? 'right-start' : 'left-start', hc = 'top', fc = 'bottom', dc = { autoClose:!0, boundary:'clippingParents', display:'dynamic', offset:[0, 2], popperConfig:null, reference:'toggle' }, pc = { autoClose:'(boolean|string)', boundary:'(string|element)', display:'string', offset:'(array|string|function)', popperConfig:'(null|object|function)', reference:'(string|element|object)' }; class ot extends Z {constructor(t, e) {super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = w.next(this._element, Pe)[0] || w.prev(this._element, Pe)[0] || w.findOne(Pe, this._parent), this._inNavbar = this._detectNavbar()} static get Default() {return dc} static get DefaultType() {return pc} static get NAME() {return ki}toggle() {return this._isShown() ? this.hide() : this.show()}show() {if (bt(this._element) || this._isShown()) return; const t = { relatedTarget:this._element }; if (!d.trigger(this._element, Yl, t).defaultPrevented) {if (this._createPopper(), 'ontouchstart' in document.documentElement && !this._parent.closest(ic)) for (const s of [].concat(...document.body.children))d.on(s, 'mouseover', He); this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.add(Bt), this._element.classList.add(Bt), d.trigger(this._element, ql, t)}}hide() {if (bt(this._element) || !this._isShown()) return; const t = { relatedTarget:this._element }; this._completeHide(t)}dispose() {this._popper && this._popper.destroy(), super.dispose()}update() {this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()}_completeHide(t) {if (!d.trigger(this._element, Ul, t).defaultPrevented) {if ('ontouchstart' in document.documentElement) for (const s of [].concat(...document.body.children))d.off(s, 'mouseover', He); this._popper && this._popper.destroy(), this._menu.classList.remove(Bt), this._element.classList.remove(Bt), this._element.setAttribute('aria-expanded', 'false'), ht.removeDataAttribute(this._menu, 'popper'), d.trigger(this._element, zl, t)}}_getConfig(t) {if (t = super._getConfig(t), typeof t.reference == 'object' && !ut(t.reference) && typeof t.reference.getBoundingClientRect != 'function') throw new TypeError(`${ki.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t}_createPopper() {if (typeof zn > 'u') throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org/docs/v2/)'); let t = this._element; this._config.reference === 'parent' ? t = this._parent : ut(this._config.reference) ? t = vt(this._config.reference) : typeof this._config.reference == 'object' && (t = this._config.reference); const e = this._getPopperConfig(); this._popper = Ws(t, this._menu, e)}_isShown() {return this._menu.classList.contains(Bt)}_getPlacement() {const t = this._parent; if (t.classList.contains(Ql)) return cc; if (t.classList.contains(Jl)) return uc; if (t.classList.contains(Zl)) return hc; if (t.classList.contains(tc)) return fc; const e = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return t.classList.contains(Xl) ? e ? oc : rc : e ? lc : ac}_detectNavbar() {return this._element.closest(sc) !== null}_getOffset() {const { offset:t } = this._config; return typeof t == 'string' ? t.split(',').map(e=>Number.parseInt(e, 10)) : typeof t == 'function' ? e=>t(e, this._element) : t}_getPopperConfig() {const t = { placement:this._getPlacement(), modifiers:[{ name:'preventOverflow', options:{ boundary:this._config.boundary } }, { name:'offset', options:{ offset:this._getOffset() } }] }; return (this._inNavbar || this._config.display === 'static') && (ht.setDataAttribute(this._menu, 'popper', 'static'), t.modifiers = [{ name:'applyStyles', enabled:!1 }]), { ...t, ...K(this._config.popperConfig, [void 0, t]) }}_selectMenuItem({ key:t, target:e }) {const s = w.find(nc, this._menu).filter(n=>te(n)); s.length && Us(s, e, t === Mi, !s.includes(e)).focus()} static jQueryInterface(t) {return this.each(function() {const e = ot.getOrCreateInstance(this, t); if (typeof t == 'string') {if (typeof e[t] > 'u') throw new TypeError(`No method named "${t}"`); e[t]()}})} static clearMenus(t) {if (t.button === Wl || t.type === 'keyup' && t.key !== Fi) return; const e = w.find(ec); for (const s of e) {const n = ot.getInstance(s); if (!n || n._config.autoClose === !1) continue; const r = t.composedPath(), o = r.includes(n._menu); if (r.includes(n._element) || n._config.autoClose === 'inside' && !o || n._config.autoClose === 'outside' && o || n._menu.contains(t.target) && (t.type === 'keyup' && t.key === Fi || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; const a = { relatedTarget:n._element }; t.type === 'click' && (a.clickEvent = t), n._completeHide(a)}} static dataApiKeydownHandler(t) {const e = /input|textarea/i.test(t.target.tagName), s = t.key === Kl, n = [Bl, Mi].includes(t.key); if (!n && !s || e && !s) return; t.preventDefault(); const r = this.matches($t) ? this : w.prev(this, $t)[0] || w.next(this, $t)[0] || w.findOne($t, t.delegateTarget.parentNode), o = ot.getOrCreateInstance(r); if (n) {t.stopPropagation(), o.show(), o._selectMenuItem(t); return}o._isShown() && (t.stopPropagation(), o.hide(), r.focus())}}d.on(document, ur, $t, ot.dataApiKeydownHandler); d.on(document, ur, Pe, ot.dataApiKeydownHandler); d.on(document, cr, ot.clearMenus); d.on(document, Gl, ot.clearMenus); d.on(document, cr, $t, function(i) {i.preventDefault(), ot.getOrCreateInstance(this).toggle()}); J(ot); const hr = 'backdrop', gc = 'fade', Vi = 'show', ji = `mousedown.bs.${hr}`, mc = { className:'modal-backdrop', clickCallback:null, isAnimated:!1, isVisible:!0, rootElement:'body' }, _c = { className:'string', clickCallback:'(function|null)', isAnimated:'boolean', isVisible:'boolean', rootElement:'(element|string)' }; class fr extends _e {constructor(t) {super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null} static get Default() {return mc} static get DefaultType() {return _c} static get NAME() {return hr}show(t) {if (!this._config.isVisible) {K(t); return} this._append(); const e = this._getElement(); this._config.isAnimated && me(e), e.classList.add(Vi), this._emulateAnimation(()=>{K(t)})}hide(t) {if (!this._config.isVisible) {K(t); return} this._getElement().classList.remove(Vi), this._emulateAnimation(()=>{this.dispose(), K(t)})}dispose() {this._isAppended && (d.off(this._element, ji), this._element.remove(), this._isAppended = !1)}_getElement() {if (!this._element) {const t = document.createElement('div'); t.className = this._config.className, this._config.isAnimated && t.classList.add(gc), this._element = t} return this._element}_configAfterMerge(t) {return t.rootElement = vt(t.rootElement), t}_append() {if (this._isAppended) return; const t = this._getElement(); this._config.rootElement.append(t), d.on(t, ji, ()=>{K(this._config.clickCallback)}), this._isAppended = !0}_emulateAnimation(t) {Qn(t, this._getElement(), this._config.isAnimated)}} const Ec = 'focustrap', vc = 'bs.focustrap', Be = `.${vc}`, bc = `focusin${Be}`, yc = `keydown.tab${Be}`, Tc = 'Tab', wc = 'forward', Hi = 'backward', Sc = { autofocus:!0, trapElement:null }, Oc = { autofocus:'boolean', trapElement:'element' }; class dr extends _e {constructor(t) {super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null} static get Default() {return Sc} static get DefaultType() {return Oc} static get NAME() {return Ec}activate() {this._isActive || (this._config.autofocus && this._config.trapElement.focus(), d.off(document, Be), d.on(document, bc, t=>this._handleFocusin(t)), d.on(document, yc, t=>this._handleKeydown(t)), this._isActive = !0)}deactivate() {this._isActive && (this._isActive = !1, d.off(document, Be))}_handleFocusin(t) {const { trapElement:e } = this._config; if (t.target === document || t.target === e || e.contains(t.target)) return; const s = w.focusableChildren(e); s.length === 0 ? e.focus() : this._lastTabNavDirection === Hi ? s[s.length - 1].focus() : s[0].focus()}_handleKeydown(t) {t.key === Tc && (this._lastTabNavDirection = t.shiftKey ? Hi : wc)}} const Ki = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top', Bi = '.sticky-top', Ce = 'padding-right', Wi = 'margin-right'; class Ns {constructor() {this._element = document.body}getWidth() {const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t)}hide() {const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, Ce, e=>e + t), this._setElementAttributes(Ki, Ce, e=>e + t), this._setElementAttributes(Bi, Wi, e=>e - t)}reset() {this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, Ce), this._resetElementAttributes(Ki, Ce), this._resetElementAttributes(Bi, Wi)}isOverflowing() {return this.getWidth() > 0}_disableOverFlow() {this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden'}_setElementAttributes(t, e, s) {const n = this.getWidth(), r = o=>{if (o !== this._element && window.innerWidth > o.clientWidth + n) return; this._saveInitialAttribute(o, e); const a = window.getComputedStyle(o).getPropertyValue(e); o.style.setProperty(e, `${s(Number.parseFloat(a))}px`)}; this._applyManipulationCallback(t, r)}_saveInitialAttribute(t, e) {const s = t.style.getPropertyValue(e); s && ht.setDataAttribute(t, e, s)}_resetElementAttributes(t, e) {const s = n=>{const r = ht.getDataAttribute(n, e); if (r === null) {n.style.removeProperty(e); return}ht.removeDataAttribute(n, e), n.style.setProperty(e, r)}; this._applyManipulationCallback(t, s)}_applyManipulationCallback(t, e) {if (ut(t)) {e(t); return} for (const s of w.find(t, this._element))e(s)}} const Ac = 'modal', xc = 'bs.modal', Q = `.${xc}`, Cc = '.data-api', $c = 'Escape', Nc = `hide${Q}`, Lc = `hidePrevented${Q}`, pr = `hidden${Q}`, gr = `show${Q}`, Dc = `shown${Q}`, Ic = `resize${Q}`, Pc = `click.dismiss${Q}`, Rc = `mousedown.dismiss${Q}`, kc = `keydown.dismiss${Q}`, Fc = `click${Q}${Cc}`, Ui = 'modal-open', Mc = 'fade', zi = 'show', hs = 'modal-static', Vc = '.modal.show', jc = '.modal-dialog', Hc = '.modal-body', Kc = '[data-bs-toggle="modal"]', Bc = { backdrop:!0, focus:!0, keyboard:!0 }, Wc = { backdrop:'(boolean|string)', focus:'boolean', keyboard:'boolean' }; class Pt extends Z {constructor(t, e) {super(t, e), this._dialog = w.findOne(jc, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ns, this._addEventListeners()} static get Default() {return Bc} static get DefaultType() {return Wc} static get NAME() {return Ac}toggle(t) {return this._isShown ? this.hide() : this.show(t)}show(t) {this._isShown || this._isTransitioning || d.trigger(this._element, gr, { relatedTarget:t }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Ui), this._adjustDialog(), this._backdrop.show(()=>this._showElement(t)))}hide() {!this._isShown || this._isTransitioning || d.trigger(this._element, Nc).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(zi), this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated()))}dispose() {d.off(window, Q), d.off(this._dialog, Q), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()}handleUpdate() {this._adjustDialog()}_initializeBackDrop() {return new fr({ isVisible:!!this._config.backdrop, isAnimated:this._isAnimated() })}_initializeFocusTrap() {return new dr({ trapElement:this._element })}_showElement(t) {document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0; const e = w.findOne(Hc, this._dialog); e && (e.scrollTop = 0), me(this._element), this._element.classList.add(zi); const s = ()=>{this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, d.trigger(this._element, Dc, { relatedTarget:t })}; this._queueCallback(s, this._dialog, this._isAnimated())}_addEventListeners() {d.on(this._element, kc, t=>{if (t.key === $c) {if (this._config.keyboard) {this.hide(); return} this._triggerBackdropTransition()}}), d.on(window, Ic, ()=>{this._isShown && !this._isTransitioning && this._adjustDialog()}), d.on(this._element, Rc, t=>{d.one(this._element, Pc, e=>{if (!(this._element !== t.target || this._element !== e.target)) {if (this._config.backdrop === 'static') {this._triggerBackdropTransition(); return} this._config.backdrop && this.hide()}})})}_hideModal() {this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide(()=>{document.body.classList.remove(Ui), this._resetAdjustments(), this._scrollBar.reset(), d.trigger(this._element, pr)})}_isAnimated() {return this._element.classList.contains(Mc)}_triggerBackdropTransition() {if (d.trigger(this._element, Lc).defaultPrevented) return; const e = this._element.scrollHeight > document.documentElement.clientHeight, s = this._element.style.overflowY; s === 'hidden' || this._element.classList.contains(hs) || (e || (this._element.style.overflowY = 'hidden'), this._element.classList.add(hs), this._queueCallback(()=>{this._element.classList.remove(hs), this._queueCallback(()=>{this._element.style.overflowY = s}, this._dialog)}, this._dialog), this._element.focus())}_adjustDialog() {const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0; if (s && !t) {const n = X() ? 'paddingLeft' : 'paddingRight'; this._element.style[n] = `${e}px`} if (!s && t) {const n = X() ? 'paddingRight' : 'paddingLeft'; this._element.style[n] = `${e}px`}}_resetAdjustments() {this._element.style.paddingLeft = '', this._element.style.paddingRight = ''} static jQueryInterface(t, e) {return this.each(function() {const s = Pt.getOrCreateInstance(this, t); if (typeof t == 'string') {if (typeof s[t] > 'u') throw new TypeError(`No method named "${t}"`); s[t](e)}})}}d.on(document, Fc, Kc, function(i) {const t = w.getElementFromSelector(this); ['A', 'AREA'].includes(this.tagName) && i.preventDefault(), d.one(t, gr, n=>{n.defaultPrevented || d.one(t, pr, ()=>{te(this) && this.focus()})}); const e = w.findOne(Vc); e && Pt.getInstance(e).hide(), Pt.getOrCreateInstance(t).toggle(this)}); qe(Pt); J(Pt); const Uc = 'offcanvas', zc = 'bs.offcanvas', dt = `.${zc}`, mr = '.data-api', Yc = `load${dt}${mr}`, qc = 'Escape', Yi = 'show', qi = 'showing', Gi = 'hiding', Gc = 'offcanvas-backdrop', _r = '.offcanvas.show', Xc = `show${dt}`, Qc = `shown${dt}`, Jc = `hide${dt}`, Xi = `hidePrevented${dt}`, Er = `hidden${dt}`, Zc = `resize${dt}`, tu = `click${dt}${mr}`, eu = `keydown.dismiss${dt}`, su = '[data-bs-toggle="offcanvas"]', iu = { backdrop:!0, keyboard:!0, scroll:!1 }, nu = { backdrop:'(boolean|string)', keyboard:'boolean', scroll:'boolean' }; class yt extends Z {constructor(t, e) {super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()} static get Default() {return iu} static get DefaultType() {return nu} static get NAME() {return Uc}toggle(t) {return this._isShown ? this.hide() : this.show(t)}show(t) {if (this._isShown || d.trigger(this._element, Xc, { relatedTarget:t }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || new Ns().hide(), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add(qi); const s = ()=>{(!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(Yi), this._element.classList.remove(qi), d.trigger(this._element, Qc, { relatedTarget:t })}; this._queueCallback(s, this._element, !0)}hide() {if (!this._isShown || d.trigger(this._element, Jc).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Gi), this._backdrop.hide(); const e = ()=>{this._element.classList.remove(Yi, Gi), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._config.scroll || new Ns().reset(), d.trigger(this._element, Er)}; this._queueCallback(e, this._element, !0)}dispose() {this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()}_initializeBackDrop() {const t = ()=>{if (this._config.backdrop === 'static') {d.trigger(this._element, Xi); return} this.hide()}, e = !!this._config.backdrop; return new fr({ className:Gc, isVisible:e, isAnimated:!0, rootElement:this._element.parentNode, clickCallback:e ? t : null })}_initializeFocusTrap() {return new dr({ trapElement:this._element })}_addEventListeners() {d.on(this._element, eu, t=>{if (t.key === qc) {if (this._config.keyboard) {this.hide(); return}d.trigger(this._element, Xi)}})} static jQueryInterface(t) {return this.each(function() {const e = yt.getOrCreateInstance(this, t); if (typeof t == 'string') {if (e[t] === void 0 || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t](this)}})}}d.on(document, tu, su, function(i) {const t = w.getElementFromSelector(this); if (['A', 'AREA'].includes(this.tagName) && i.preventDefault(), bt(this)) return; d.one(t, Er, ()=>{te(this) && this.focus()}); const e = w.findOne(_r); e && e !== t && yt.getInstance(e).hide(), yt.getOrCreateInstance(t).toggle(this)}); d.on(window, Yc, ()=>{for (const i of w.find(_r))yt.getOrCreateInstance(i).show()}); d.on(window, Zc, ()=>{for (const i of w.find('[aria-modal][class*=show][class*=offcanvas-]'))getComputedStyle(i).position !== 'fixed' && yt.getOrCreateInstance(i).hide()}); qe(yt); J(yt); const ru = /^aria-[\w-]*$/i, vr = { '*':['class', 'dir', 'id', 'lang', 'role', ru], a:['target', 'href', 'title', 'rel'], area:[], b:[], br:[], col:[], code:[], dd:[], div:[], dl:[], dt:[], em:[], hr:[], h1:[], h2:[], h3:[], h4:[], h5:[], h6:[], i:[], img:['src', 'srcset', 'alt', 'title', 'width', 'height'], li:[], ol:[], p:[], pre:[], s:[], small:[], span:[], sub:[], sup:[], strong:[], u:[], ul:[] }, ou = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']), au = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, lu = (i, t)=>{const e = i.nodeName.toLowerCase(); return t.includes(e) ? ou.has(e) ? !!au.test(i.nodeValue) : !0 : t.filter(s=>s instanceof RegExp).some(s=>s.test(e))}; function cu(i, t, e) {if (!i.length) return i; if (e && typeof e == 'function') return e(i); const n = new window.DOMParser().parseFromString(i, 'text/html'), r = [].concat(...n.body.querySelectorAll('*')); for (const o of r) {const a = o.nodeName.toLowerCase(); if (!Object.keys(t).includes(a)) {o.remove(); continue} const l = [].concat(...o.attributes), c = [].concat(t['*'] || [], t[a] || []); for (const u of l)lu(u, c) || o.removeAttribute(u.nodeName)} return n.body.innerHTML} const uu = 'TemplateFactory', hu = { allowList:vr, content:{}, extraClass:'', html:!1, sanitize:!0, sanitizeFn:null, template:'<div></div>' }, fu = { allowList:'object', content:'object', extraClass:'(string|function)', html:'boolean', sanitize:'boolean', sanitizeFn:'(null|function)', template:'string' }, du = { entry:'(string|element|function|null)', selector:'(string|element)' }; class pu extends _e {constructor(t) {super(), this._config = this._getConfig(t)} static get Default() {return hu} static get DefaultType() {return fu} static get NAME() {return uu}getContent() {return Object.values(this._config.content).map(t=>this._resolvePossibleFunction(t)).filter(Boolean)}hasContent() {return this.getContent().length > 0}changeContent(t) {return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this}toHtml() {const t = document.createElement('div'); t.innerHTML = this._maybeSanitize(this._config.template); for (const [n, r] of Object.entries(this._config.content)) this._setContent(t, r, n); const e = t.children[0], s = this._resolvePossibleFunction(this._config.extraClass); return s && e.classList.add(...s.split(' ')), e}_typeCheckConfig(t) {super._typeCheckConfig(t), this._checkContent(t.content)}_checkContent(t) {for (const [e, s] of Object.entries(t)) super._typeCheckConfig({ selector:e, entry:s }, du)}_setContent(t, e, s) {const n = w.findOne(s, t); if (n) {if (e = this._resolvePossibleFunction(e), !e) {n.remove(); return} if (ut(e)) {this._putElementInTemplate(vt(e), n); return} if (this._config.html) {n.innerHTML = this._maybeSanitize(e); return}n.textContent = e}}_maybeSanitize(t) {return this._config.sanitize ? cu(t, this._config.allowList, this._config.sanitizeFn) : t}_resolvePossibleFunction(t) {return K(t, [void 0, this])}_putElementInTemplate(t, e) {if (this._config.html) {e.innerHTML = '', e.append(t); return}e.textContent = t.textContent}} const gu = 'tooltip', mu = new Set(['sanitize', 'allowList', 'sanitizeFn']), fs = 'fade', _u = 'modal', $e = 'show', Eu = '.tooltip-inner', Qi = `.${_u}`, Ji = 'hide.bs.modal', oe = 'hover', ds = 'focus', ps = 'click', vu = 'manual', bu = 'hide', yu = 'hidden', Tu = 'show', wu = 'shown', Su = 'inserted', Ou = 'click', Au = 'focusin', xu = 'focusout', Cu = 'mouseenter', $u = 'mouseleave', Nu = { AUTO:'auto', TOP:'top', RIGHT:X() ? 'left' : 'right', BOTTOM:'bottom', LEFT:X() ? 'right' : 'left' }, Lu = { allowList:vr, animation:!0, boundary:'clippingParents', container:!1, customClass:'', delay:0, fallbackPlacements:['top', 'right', 'bottom', 'left'], html:!1, offset:[0, 6], placement:'top', popperConfig:null, sanitize:!0, sanitizeFn:null, selector:!1, template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title:'', trigger:'hover focus' }, Du = { allowList:'object', animation:'boolean', boundary:'(string|element)', container:'(string|element|boolean)', customClass:'(string|function)', delay:'(number|object)', fallbackPlacements:'array', html:'boolean', offset:'(array|string|function)', placement:'(string|function)', popperConfig:'(null|object|function)', sanitize:'boolean', sanitizeFn:'(null|function)', selector:'(string|boolean)', template:'string', title:'(string|element|function)', trigger:'string' }; class se extends Z {constructor(t, e) {if (typeof zn > 'u') throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org/docs/v2/)'); super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle()} static get Default() {return Lu} static get DefaultType() {return Du} static get NAME() {return gu}enable() {this._isEnabled = !0}disable() {this._isEnabled = !1}toggleEnabled() {this._isEnabled = !this._isEnabled}toggle() {if (this._isEnabled) {if (this._isShown()) {this._leave(); return} this._enter()}}dispose() {clearTimeout(this._timeout), d.off(this._element.closest(Qi), Ji, this._hideModalHandler), this._element.getAttribute('data-bs-original-title') && this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title')), this._disposePopper(), super.dispose()}show() {if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!(this._isWithContent() && this._isEnabled)) return; const t = d.trigger(this._element, this.constructor.eventName(Tu)), s = (Gn(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (t.defaultPrevented || !s) return; this._disposePopper(); const n = this._getTipElement(); this._element.setAttribute('aria-describedby', n.getAttribute('id')); const { container:r } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (r.append(n), d.trigger(this._element, this.constructor.eventName(Su))), this._popper = this._createPopper(n), n.classList.add($e), 'ontouchstart' in document.documentElement) for (const a of [].concat(...document.body.children))d.on(a, 'mouseover', He); const o = ()=>{d.trigger(this._element, this.constructor.eventName(wu)), this._isHovered === !1 && this._leave(), this._isHovered = !1}; this._queueCallback(o, this.tip, this._isAnimated())}hide() {if (!this._isShown() || d.trigger(this._element, this.constructor.eventName(bu)).defaultPrevented) return; if (this._getTipElement().classList.remove($e), 'ontouchstart' in document.documentElement) for (const n of [].concat(...document.body.children))d.off(n, 'mouseover', He); this._activeTrigger[ps] = !1, this._activeTrigger[ds] = !1, this._activeTrigger[oe] = !1, this._isHovered = null; const s = ()=>{this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute('aria-describedby'), d.trigger(this._element, this.constructor.eventName(yu)))}; this._queueCallback(s, this.tip, this._isAnimated())}update() {this._popper && this._popper.update()}_isWithContent() {return !!this._getTitle()}_getTipElement() {return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip}_createTipElement(t) {const e = this._getTemplateFactory(t).toHtml(); if (!e) return null; e.classList.remove(fs, $e), e.classList.add(`bs-${this.constructor.NAME}-auto`); const s = va(this.constructor.NAME).toString(); return e.setAttribute('id', s), this._isAnimated() && e.classList.add(fs), e}setContent(t) {this._newContent = t, this._isShown() && (this._disposePopper(), this.show())}_getTemplateFactory(t) {return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new pu({ ...this._config, content:t, extraClass:this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory}_getContentForTemplate() {return { [Eu]:this._getTitle() }}_getTitle() {return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title')}_initializeOnDelegatedTarget(t) {return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())}_isAnimated() {return this._config.animation || this.tip && this.tip.classList.contains(fs)}_isShown() {return this.tip && this.tip.classList.contains($e)}_createPopper(t) {const e = K(this._config.placement, [this, t, this._element]), s = Nu[e.toUpperCase()]; return Ws(this._element, t, this._getPopperConfig(s))}_getOffset() {const { offset:t } = this._config; return typeof t == 'string' ? t.split(',').map(e=>Number.parseInt(e, 10)) : typeof t == 'function' ? e=>t(e, this._element) : t}_resolvePossibleFunction(t) {return K(t, [this._element, this._element])}_getPopperConfig(t) {const e = { placement:t, modifiers:[{ name:'flip', options:{ fallbackPlacements:this._config.fallbackPlacements } }, { name:'offset', options:{ offset:this._getOffset() } }, { name:'preventOverflow', options:{ boundary:this._config.boundary } }, { name:'arrow', options:{ element:`.${this.constructor.NAME}-arrow` } }, { name:'preSetPlacement', enabled:!0, phase:'beforeMain', fn:s=>{this._getTipElement().setAttribute('data-popper-placement', s.state.placement)} }] }; return { ...e, ...K(this._config.popperConfig, [void 0, e]) }}_setListeners() {const t = this._config.trigger.split(' '); for (const e of t) if (e === 'click')d.on(this._element, this.constructor.eventName(Ou), this._config.selector, s=>{const n = this._initializeOnDelegatedTarget(s); n._activeTrigger[ps] = !(n._isShown() && n._activeTrigger[ps]), n.toggle()}); else if (e !== vu) {const s = e === oe ? this.constructor.eventName(Cu) : this.constructor.eventName(Au), n = e === oe ? this.constructor.eventName($u) : this.constructor.eventName(xu); d.on(this._element, s, this._config.selector, r=>{const o = this._initializeOnDelegatedTarget(r); o._activeTrigger[r.type === 'focusin' ? ds : oe] = !0, o._enter()}), d.on(this._element, n, this._config.selector, r=>{const o = this._initializeOnDelegatedTarget(r); o._activeTrigger[r.type === 'focusout' ? ds : oe] = o._element.contains(r.relatedTarget), o._leave()})} this._hideModalHandler = ()=>{this._element && this.hide()}, d.on(this._element.closest(Qi), Ji, this._hideModalHandler)}_fixTitle() {const t = this._element.getAttribute('title'); t && (!this._element.getAttribute('aria-label') && !this._element.textContent.trim() && this._element.setAttribute('aria-label', t), this._element.setAttribute('data-bs-original-title', t), this._element.removeAttribute('title'))}_enter() {if (this._isShown() || this._isHovered) {this._isHovered = !0; return} this._isHovered = !0, this._setTimeout(()=>{this._isHovered && this.show()}, this._config.delay.show)}_leave() {this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(()=>{this._isHovered || this.hide()}, this._config.delay.hide))}_setTimeout(t, e) {clearTimeout(this._timeout), this._timeout = setTimeout(t, e)}_isWithActiveTrigger() {return Object.values(this._activeTrigger).includes(!0)}_getConfig(t) {const e = ht.getDataAttributes(this._element); for (const s of Object.keys(e))mu.has(s) && delete e[s]; return t = { ...e, ...typeof t == 'object' && t ? t : {} }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t}_configAfterMerge(t) {return t.container = t.container === !1 ? document.body : vt(t.container), typeof t.delay == 'number' && (t.delay = { show:t.delay, hide:t.delay }), typeof t.title == 'number' && (t.title = t.title.toString()), typeof t.content == 'number' && (t.content = t.content.toString()), t}_getDelegateConfig() {const t = {}; for (const [e, s] of Object.entries(this._config)) this.constructor.Default[e] !== s && (t[e] = s); return t.selector = !1, t.trigger = 'manual', t}_disposePopper() {this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null)} static jQueryInterface(t) {return this.each(function() {const e = se.getOrCreateInstance(this, t); if (typeof t == 'string') {if (typeof e[t] > 'u') throw new TypeError(`No method named "${t}"`); e[t]()}})}}J(se); const Iu = 'popover', Pu = '.popover-header', Ru = '.popover-body', ku = { ...se.Default, content:'', offset:[0, 8], placement:'right', template:'<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger:'click' }, Fu = { ...se.DefaultType, content:'(null|string|element|function)' }; class qs extends se {static get Default() {return ku} static get DefaultType() {return Fu} static get NAME() {return Iu}_isWithContent() {return this._getTitle() || this._getContent()}_getContentForTemplate() {return { [Pu]:this._getTitle(), [Ru]:this._getContent() }}_getContent() {return this._resolvePossibleFunction(this._config.content)} static jQueryInterface(t) {return this.each(function() {const e = qs.getOrCreateInstance(this, t); if (typeof t == 'string') {if (typeof e[t] > 'u') throw new TypeError(`No method named "${t}"`); e[t]()}})}}J(qs); const Mu = 'scrollspy', Vu = 'bs.scrollspy', Gs = `.${Vu}`, ju = '.data-api', Hu = `activate${Gs}`, Zi = `click${Gs}`, Ku = `load${Gs}${ju}`, Bu = 'dropdown-item', jt = 'active', Wu = '[data-bs-spy="scroll"]', gs = '[href]', Uu = '.nav, .list-group', tn = '.nav-link', zu = '.nav-item', Yu = '.list-group-item', qu = `${tn}, ${zu} > ${tn}, ${Yu}`, Gu = '.dropdown', Xu = '.dropdown-toggle', Qu = { offset:null, rootMargin:'0px 0px -25%', smoothScroll:!1, target:null, threshold:[.1, .5, 1] }, Ju = { offset:'(number|null)', rootMargin:'string', smoothScroll:'boolean', target:'element', threshold:'array' }; class Qe extends Z {constructor(t, e) {super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop:0, parentScrollTop:0 }, this.refresh()} static get Default() {return Qu} static get DefaultType() {return Ju} static get NAME() {return Mu}refresh() {this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const t of this._observableSections.values()) this._observer.observe(t)}dispose() {this._observer.disconnect(), super.dispose()}_configAfterMerge(t) {return t.target = vt(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, typeof t.threshold == 'string' && (t.threshold = t.threshold.split(',').map(e=>Number.parseFloat(e))), t}_maybeEnableSmoothScroll() {this._config.smoothScroll && (d.off(this._config.target, Zi), d.on(this._config.target, Zi, gs, t=>{const e = this._observableSections.get(t.target.hash); if (e) {t.preventDefault(); const s = this._rootElement || window, n = e.offsetTop - this._element.offsetTop; if (s.scrollTo) {s.scrollTo({ top:n, behavior:'smooth' }); return}s.scrollTop = n}}))}_getNewObserver() {const t = { root:this._rootElement, threshold:this._config.threshold, rootMargin:this._config.rootMargin }; return new IntersectionObserver(e=>this._observerCallback(e), t)}_observerCallback(t) {const e = o=>this._targetLinks.get(`#${o.target.id}`), s = o=>{this._previousScrollData.visibleEntryTop = o.target.offsetTop, this._process(e(o))}, n = (this._rootElement || document.documentElement).scrollTop, r = n >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = n; for (const o of t) {if (!o.isIntersecting) {this._activeTarget = null, this._clearActiveClass(e(o)); continue} const a = o.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (r && a) {if (s(o), !n) return; continue}!r && !a && s(o)}}_initializeTargetsAndObservables() {this._targetLinks = new Map, this._observableSections = new Map; const t = w.find(gs, this._config.target); for (const e of t) {if (!e.hash || bt(e)) continue; const s = w.findOne(decodeURI(e.hash), this._element); te(s) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, s))}}_process(t) {this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(jt), this._activateParents(t), d.trigger(this._element, Hu, { relatedTarget:t }))}_activateParents(t) {if (t.classList.contains(Bu)) {w.findOne(Xu, t.closest(Gu)).classList.add(jt); return} for (const e of w.parents(t, Uu)) for (const s of w.prev(e, qu))s.classList.add(jt)}_clearActiveClass(t) {t.classList.remove(jt); const e = w.find(`${gs}.${jt}`, t); for (const s of e)s.classList.remove(jt)} static jQueryInterface(t) {return this.each(function() {const e = Qe.getOrCreateInstance(this, t); if (typeof t == 'string') {if (e[t] === void 0 || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t]()}})}}d.on(window, Ku, ()=>{for (const i of w.find(Wu))Qe.getOrCreateInstance(i)}); J(Qe); const Zu = 'tab', th = 'bs.tab', kt = `.${th}`, eh = `hide${kt}`, sh = `hidden${kt}`, ih = `show${kt}`, nh = `shown${kt}`, rh = `click${kt}`, oh = `keydown${kt}`, ah = `load${kt}`, lh = 'ArrowLeft', en = 'ArrowRight', ch = 'ArrowUp', sn = 'ArrowDown', ms = 'Home', nn = 'End', Nt = 'active', rn = 'fade', _s = 'show', uh = 'dropdown', br = '.dropdown-toggle', hh = '.dropdown-menu', Es = `:not(${br})`, fh = '.list-group, .nav, [role="tablist"]', dh = '.nav-item, .list-group-item', ph = `.nav-link${Es}, .list-group-item${Es}, [role="tab"]${Es}`, yr = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', vs = `${ph}, ${yr}`, gh = `.${Nt}[data-bs-toggle="tab"], .${Nt}[data-bs-toggle="pill"], .${Nt}[data-bs-toggle="list"]`; class Jt extends Z {constructor(t) {super(t), this._parent = this._element.closest(fh), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), d.on(this._element, oh, e=>this._keydown(e)))} static get NAME() {return Zu}show() {const t = this._element; if (this._elemIsActive(t)) return; const e = this._getActiveElem(), s = e ? d.trigger(e, eh, { relatedTarget:t }) : null; d.trigger(t, ih, { relatedTarget:e }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(e, t), this._activate(t, e))}_activate(t, e) {if (!t) return; t.classList.add(Nt), this._activate(w.getElementFromSelector(t)); const s = ()=>{if (t.getAttribute('role') !== 'tab') {t.classList.add(_s); return}t.removeAttribute('tabindex'), t.setAttribute('aria-selected', !0), this._toggleDropDown(t, !0), d.trigger(t, nh, { relatedTarget:e })}; this._queueCallback(s, t, t.classList.contains(rn))}_deactivate(t, e) {if (!t) return; t.classList.remove(Nt), t.blur(), this._deactivate(w.getElementFromSelector(t)); const s = ()=>{if (t.getAttribute('role') !== 'tab') {t.classList.remove(_s); return}t.setAttribute('aria-selected', !1), t.setAttribute('tabindex', '-1'), this._toggleDropDown(t, !1), d.trigger(t, sh, { relatedTarget:e })}; this._queueCallback(s, t, t.classList.contains(rn))}_keydown(t) {if (![lh, en, ch, sn, ms, nn].includes(t.key)) return; t.stopPropagation(), t.preventDefault(); const e = this._getChildren().filter(n=>!bt(n)); let s; if ([ms, nn].includes(t.key))s = e[t.key === ms ? 0 : e.length - 1]; else {const n = [en, sn].includes(t.key); s = Us(e, t.target, n, !0)}s && (s.focus({ preventScroll:!0 }), Jt.getOrCreateInstance(s).show())}_getChildren() {return w.find(vs, this._parent)}_getActiveElem() {return this._getChildren().find(t=>this._elemIsActive(t)) || null}_setInitialAttributes(t, e) {this._setAttributeIfNotExists(t, 'role', 'tablist'); for (const s of e) this._setInitialAttributesOnChild(s)}_setInitialAttributesOnChild(t) {t = this._getInnerElement(t); const e = this._elemIsActive(t), s = this._getOuterElement(t); t.setAttribute('aria-selected', e), s !== t && this._setAttributeIfNotExists(s, 'role', 'presentation'), e || t.setAttribute('tabindex', '-1'), this._setAttributeIfNotExists(t, 'role', 'tab'), this._setInitialAttributesOnTargetPanel(t)}_setInitialAttributesOnTargetPanel(t) {const e = w.getElementFromSelector(t); e && (this._setAttributeIfNotExists(e, 'role', 'tabpanel'), t.id && this._setAttributeIfNotExists(e, 'aria-labelledby', `${t.id}`))}_toggleDropDown(t, e) {const s = this._getOuterElement(t); if (!s.classList.contains(uh)) return; const n = (r, o)=>{const a = w.findOne(r, s); a && a.classList.toggle(o, e)}; n(br, Nt), n(hh, _s), s.setAttribute('aria-expanded', e)}_setAttributeIfNotExists(t, e, s) {t.hasAttribute(e) || t.setAttribute(e, s)}_elemIsActive(t) {return t.classList.contains(Nt)}_getInnerElement(t) {return t.matches(vs) ? t : w.findOne(vs, t)}_getOuterElement(t) {return t.closest(dh) || t} static jQueryInterface(t) {return this.each(function() {const e = Jt.getOrCreateInstance(this); if (typeof t == 'string') {if (e[t] === void 0 || t.startsWith('_') || t === 'constructor') throw new TypeError(`No method named "${t}"`); e[t]()}})}}d.on(document, rh, yr, function(i) {['A', 'AREA'].includes(this.tagName) && i.preventDefault(), !bt(this) && Jt.getOrCreateInstance(this).show()}); d.on(window, ah, ()=>{for (const i of w.find(gh))Jt.getOrCreateInstance(i)}); J(Jt); const mh = 'toast', _h = 'bs.toast', St = `.${_h}`, Eh = `mouseover${St}`, vh = `mouseout${St}`, bh = `focusin${St}`, yh = `focusout${St}`, Th = `hide${St}`, wh = `hidden${St}`, Sh = `show${St}`, Oh = `shown${St}`, Ah = 'fade', on = 'hide', Ne = 'show', Le = 'showing', xh = { animation:'boolean', autohide:'boolean', delay:'number' }, Ch = { animation:!0, autohide:!0, delay:5e3 }; class Je extends Z {constructor(t, e) {super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()} static get Default() {return Ch} static get DefaultType() {return xh} static get NAME() {return mh}show() {if (d.trigger(this._element, Sh).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(Ah); const e = ()=>{this._element.classList.remove(Le), d.trigger(this._element, Oh), this._maybeScheduleHide()}; this._element.classList.remove(on), me(this._element), this._element.classList.add(Ne, Le), this._queueCallback(e, this._element, this._config.animation)}hide() {if (!this.isShown() || d.trigger(this._element, Th).defaultPrevented) return; const e = ()=>{this._element.classList.add(on), this._element.classList.remove(Le, Ne), d.trigger(this._element, wh)}; this._element.classList.add(Le), this._queueCallback(e, this._element, this._config.animation)}dispose() {this._clearTimeout(), this.isShown() && this._element.classList.remove(Ne), super.dispose()}isShown() {return this._element.classList.contains(Ne)}_maybeScheduleHide() {this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{this.hide()}, this._config.delay)))}_onInteraction(t, e) {switch (t.type) {case 'mouseover':case 'mouseout':{this._hasMouseInteraction = e; break} case 'focusin':case 'focusout':{this._hasKeyboardInteraction = e; break}} if (e) {this._clearTimeout(); return} const s = t.relatedTarget; this._element === s || this._element.contains(s) || this._maybeScheduleHide()}_setListeners() {d.on(this._element, Eh, t=>this._onInteraction(t, !0)), d.on(this._element, vh, t=>this._onInteraction(t, !1)), d.on(this._element, bh, t=>this._onInteraction(t, !0)), d.on(this._element, yh, t=>this._onInteraction(t, !1))}_clearTimeout() {clearTimeout(this._timeout), this._timeout = null} static jQueryInterface(t) {return this.each(function() {const e = Je.getOrCreateInstance(this, t); if (typeof t == 'string') {if (typeof e[t] > 'u') throw new TypeError(`No method named "${t}"`); e[t](this)}})}}qe(Je); J(Je); const $h = document.getElementById('rss-form'), ae = document.getElementById('url-input'), mt = document.querySelector('.feedback'), Nh = document.querySelector('.feeds'), an = document.querySelector('.posts'), Lh = document.getElementById('postModal'), Dh = document.getElementById('modalTitle'), Ih = document.getElementById('modalBody'), Ph = document.querySelector('.full-article'), Rh = new Pt(Lh), W = { feeds:[], posts:[], readPosts:new Set }; ao({ string:{ url:()=>zt.t('errors.invalidUrl') }, mixed:{ required:()=>zt.t('errors.required'), notOneOf:()=>zt.t('errors.alreadyExists') } }); const kh = i=>_n().url().notOneOf(i.map(t=>t.url)).required(), Tr = (i, t)=>{const s = new DOMParser().parseFromString(i, 'text/xml'); if (s.querySelector('parsererror')) throw new Error('parseError'); const n = crypto.randomUUID(), r = { id:n, title:s.querySelector('channel > title')?.textContent || 'Без названия', description:s.querySelector('channel > description')?.textContent || '', url:t }, o = Array.from(s.querySelectorAll('item')).map(a=>({ id:crypto.randomUUID(), feedId:n, title:a.querySelector('title')?.textContent || 'Без названия', link:a.querySelector('link')?.textContent || '#', description:a.querySelector('description')?.textContent || '' })); return { feed:r, posts:o }}, Fh = i=>{Nh.innerHTML = `
    <h2>Фиды</h2>
    <ul class="list-group mb-3">
      ${i.map(t=>`
          <li class="list-group-item">
            <h5>${t.title}</h5>
            <p>${t.description}</p>
          </li>
        `).join('')}
    </ul>
  `}, Xs = i=>{an.innerHTML = `
    <h2>Посты</h2>
    <ul class="list-group">
      ${i.map(t=>`
          <li class="list-group-item d-flex justify-content-between align-items-start">
            <a 
              href="${t.link}" 
              target="_blank" 
              rel="noopener noreferrer"
              class="${W.readPosts.has(t.id) ? 'fw-normal' : 'fw-bold'}"
              data-id="${t.id}"
            >
              ${t.title}
            </a>
            <button 
              type="button" 
              class="btn btn-outline-primary btn-sm ms-3 preview-btn" 
              data-id="${t.id}"
            >
              Просмотр
            </button>
          </li>
        `).join('')}
    </ul>
  `, an.querySelectorAll('.preview-btn').forEach(t=>{t.addEventListener('click', e=>{const s = e.target.dataset.id, n = W.posts.find(r=>r.id === s); n && (W.readPosts.add(s), Xs(W.posts), Dh.textContent = n.title, Ih.textContent = n.description, Ph.href = n.link, Rh.show())})})}; $h.addEventListener('submit', i=>{i.preventDefault(); const t = ae.value.trim(); kh(W.feeds).validate(t).then(s=>(ae.classList.remove('is-invalid'), mt.textContent = '', mt.classList.remove('text-danger'), fetch(`https://api.allorigins.win/get?disableCache=true&url=${encodeURIComponent(s)}`).then(n=>{if (!n.ok) throw new Error('network'); return n.json()}).then(({ contents:n })=>{let r = n; if (r.startsWith('data:application/rss+xml')) {const l = r.split(',')[1]; r = atob(l)} const { feed:o, posts:a } = Tr(r, s); W.feeds.push(o), W.posts.push(...a), Fh(W.feeds), Xs(W.posts), mt.classList.add('text-success'), mt.textContent = zt.t('success'), ae.value = '', ae.focus()}))).catch(s=>{ae.classList.add('is-invalid'), mt.classList.remove('text-success'), mt.classList.add('text-danger'), s.name === 'ValidationError' ? mt.textContent = s.message : mt.textContent = zt.t(`errors.${s.message}`, { defaultValue:s.message })})}); const wr = ()=>{console.log('Проверка RSS-фидов…', new Date().toLocaleTimeString()); const i = W.feeds.map(t=>fetch(`https://api.allorigins.win/get?disableCache=true&url=${encodeURIComponent(t.url)}`).then(e=>{if (!e.ok) throw new Error('network'); return e.json()}).then(({ contents:e })=>{let s = e; if (s.startsWith('data:application/rss+xml')) {const o = s.split(',')[1]; s = atob(o)} const { posts:n } = Tr(s, t.url), r = n.filter(o=>!W.posts.some(a=>a.link === o.link)); r.length > 0 && (W.posts.push(...r), Xs(W.posts), console.log(`Добавлено ${r.length} новых постов из ${t.title}`))}).catch(e=>{console.warn(`Ошибка обновления фида ${t.url}:`, e.message)})); Promise.all(i).finally(()=>setTimeout(wr, 5e3))}; wr()
